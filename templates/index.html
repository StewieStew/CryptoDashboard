<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Crypto Analysis Dashboard</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    :root {
      --bg-base:    #0d1117;
      --bg-card:    #161b22;
      --bg-card2:   #1c2128;
      --border:     #30363d;
      --text-dim:   #8b949e;
      --green:      #3fb950;
      --red:        #f85149;
      --yellow:     #d29922;
      --blue:       #58a6ff;
      --purple:     #bc8cff;
      --orange:     #f0883e;
    }
    body { background: var(--bg-base); font-family: 'Segoe UI', system-ui, sans-serif; }
    .navbar-custom { background: var(--bg-card); border-bottom: 1px solid var(--border); padding: 10px 16px; }
    .sym-btn {
      background: var(--bg-card2); border: 1px solid var(--border); color: #e6edf3;
      border-radius: 6px; padding: 4px 14px; font-size: 13px; font-weight: 600;
      cursor: pointer; transition: all .15s;
    }
    .sym-btn:hover  { border-color: var(--blue); color: var(--blue); }
    .sym-btn.active { background: var(--blue); border-color: var(--blue); color: #fff; }
    .sym-btn.remove { font-size: 10px; padding: 2px 6px; color: var(--red); background: transparent; border: none; }

    /* Hero metrics */
    .hero { background: var(--bg-card); border-bottom: 1px solid var(--border); padding: 10px 16px; display: flex; gap: 24px; flex-wrap: wrap; align-items: center; }
    .metric { display: flex; flex-direction: column; }
    .metric .label { font-size: 10px; color: var(--text-dim); text-transform: uppercase; letter-spacing: .06em; }
    .metric .value { font-size: 18px; font-weight: 700; color: #e6edf3; line-height: 1.2; }
    .metric .value.sm { font-size: 14px; }

    /* Charts */
    .chart-section { padding: 12px 16px 0; }
    #main-chart, #rsi-chart, #obv-chart { width: 100%; border-radius: 6px; overflow: hidden; }
    #main-chart { height: 480px; }
    #rsi-chart  { height: 110px; margin-top: 2px; }
    #obv-chart  { height: 80px;  margin-top: 2px; }
    .chart-legend { font-size: 11px; color: var(--text-dim); padding: 4px 0; display: flex; gap: 16px; }
    .legend-dot { display: inline-block; width: 10px; height: 2px; vertical-align: middle; margin-right: 4px; }

    /* Cards */
    .card-section { padding: 12px 16px; }
    .analysis-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px; height: 100%; }
    .card-hdr { font-size: 10px; color: var(--text-dim); text-transform: uppercase; letter-spacing: .08em; font-weight: 600; padding: 10px 14px 6px; border-bottom: 1px solid var(--border); }
    .card-body-inner { padding: 12px 14px; }

    /* Tables inside cards */
    .info-row { display: flex; justify-content: space-between; align-items: flex-start; padding: 4px 0; border-bottom: 1px solid #21262d; font-size: 13px; }
    .info-row:last-child { border-bottom: none; }
    .info-label { color: var(--text-dim); }
    .info-val   { text-align: right; font-weight: 500; }

    /* Badges */
    .badge-regime { display: inline-block; font-size: 13px; font-weight: 700; padding: 4px 10px; border-radius: 5px; margin-bottom: 8px; }

    /* Confluence bar */
    .conf-bar-wrap { background: #21262d; border-radius: 4px; height: 10px; width: 100%; overflow: hidden; margin: 6px 0; }
    .conf-bar-fill { height: 100%; border-radius: 4px; transition: width .4s; }
    .conf-reason { font-size: 12px; padding: 3px 0; display: flex; align-items: flex-start; gap: 6px; }
    .conf-dot { width: 7px; height: 7px; border-radius: 50%; margin-top: 4px; flex-shrink: 0; }

    /* Score badge */
    .score-badge { font-size: 36px; font-weight: 800; line-height: 1; }
    .score-label { font-size: 11px; text-transform: uppercase; letter-spacing: .06em; margin-top: 2px; }

    /* Fib table */
    .fib-row { display: flex; justify-content: space-between; font-size: 12px; padding: 3px 0; border-bottom: 1px solid #21262d; }
    .fib-row.active { background: rgba(208,146,34,.12); border-radius: 4px; padding: 3px 6px; }

    /* Sweep pill */
    .sweep-pill { font-size: 11px; padding: 2px 8px; border-radius: 20px; display: inline-block; margin: 2px 2px 2px 0; }

    /* Level pills */
    .level-pill { font-size: 12px; padding: 2px 8px; border-radius: 4px; display: inline-block; margin: 2px 2px 2px 0; font-weight: 600; }

    /* Loading */
    #loading-overlay {
      position: fixed; inset: 0; background: rgba(13,17,23,.9);
      display: flex; align-items: center; justify-content: center;
      z-index: 9999; flex-direction: column; gap: 12px;
    }
    .spinner { width: 36px; height: 36px; border: 3px solid var(--border); border-top-color: var(--blue); border-radius: 50%; animation: spin .8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Error */
    #error-banner { display: none; background: #3d1a1a; border: 1px solid var(--red); color: var(--red); padding: 10px 16px; font-size: 13px; }

    /* Add symbol modal */
    .modal-content { background: var(--bg-card); border: 1px solid var(--border); }

    /* Timestamp */
    #timestamp { font-size: 11px; color: var(--text-dim); }

    /* Scrollable swing list */
    .swing-list { max-height: 120px; overflow-y: auto; }
    .swing-item { display: flex; justify-content: space-between; font-size: 12px; padding: 3px 0; border-bottom: 1px solid #21262d; }
    .swing-item:last-child { border-bottom: none; }

    .text-g { color: var(--green) !important; }
    .text-r { color: var(--red) !important; }
    .text-y { color: var(--yellow) !important; }
    .text-b { color: var(--blue) !important; }
    .text-p { color: var(--purple) !important; }
    .text-o { color: var(--orange) !important; }
    .text-dim { color: var(--text-dim) !important; }

    /* Timeframe switcher */
    .tf-btn {
      background: var(--bg-card2); border: 1px solid var(--border); color: #8b949e;
      border-radius: 4px; padding: 2px 10px; font-size: 12px; font-weight: 600;
      cursor: pointer; transition: all .12s;
    }
    .tf-btn:hover  { border-color: var(--blue); color: var(--blue); }
    .tf-btn.active { background: var(--bg-card2); border-color: var(--blue); color: var(--blue); }
    #tf-label { font-size: 10px; color: #484f58; margin-left: 8px; }

    /* Methodology modal */
    .method-modal .modal-content { background: var(--bg-base); border: none; }
    .method-modal .modal-header  { background: var(--bg-card); border-bottom: 1px solid var(--border); padding: 12px 20px; }
    .method-nav { padding: 12px 0; }
    .method-nav a {
      display: block; padding: 7px 16px; font-size: 13px; color: #8b949e;
      text-decoration: none; border-left: 2px solid transparent; transition: all .12s;
    }
    .method-nav a:hover  { color: #e6edf3; background: #161b22; }
    .method-nav a.active { color: var(--blue); border-left-color: var(--blue); background: #161b22; }
    .method-section { padding: 0 0 40px; scroll-margin-top: 20px; }
    .method-title   { font-size: 18px; font-weight: 700; color: #e6edf3; margin-bottom: 6px; border-bottom: 1px solid var(--border); padding-bottom: 10px; }
    .method-lead    { font-size: 14px; color: #8b949e; margin-bottom: 16px; line-height: 1.6; }
    .method-block   { background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px; padding: 14px 16px; margin-bottom: 12px; }
    .method-block-title { font-size: 12px; font-weight: 700; color: var(--blue); text-transform: uppercase; letter-spacing: .06em; margin-bottom: 8px; }
    .method-formula {
      font-family: 'Courier New', monospace; font-size: 12px; color: var(--purple);
      background: #0d1117; border: 1px solid #21262d; border-radius: 4px;
      padding: 8px 12px; margin: 8px 0; line-height: 1.8;
    }
    .method-p { font-size: 13px; color: #8b949e; line-height: 1.7; margin: 8px 0 0; }
    .method-table { width: 100%; font-size: 12px; border-collapse: collapse; margin-top: 8px; }
    .method-table td { padding: 5px 8px; border-bottom: 1px solid #21262d; color: #8b949e; }
    .method-table td:first-child { color: #e6edf3; font-weight: 600; width: 200px; }
    .method-tag {
      display: inline-block; font-size: 11px; padding: 1px 7px; border-radius: 3px;
      margin: 2px; font-weight: 600;
    }
    .method-divider { border: none; border-top: 1px solid var(--border); margin: 32px 0; }

    /* Signal overlay on chart */
    #chart-wrap { position: relative; }
    #signal-overlay {
      display: none;
      position: absolute; top: 12px; left: 12px; z-index: 10;
      background: rgba(13,17,23,0.93);
      border: 1px solid #30363d;
      border-radius: 8px; padding: 10px 14px;
      min-width: 210px; max-width: 260px;
      pointer-events: none;
    }
    #signal-overlay.no-signal {
      display: block;
      border-color: #21262d;
    }

    /* Chart tooltip on price lines */
    #chart-tooltip {
      display: none;
      position: absolute;
      z-index: 20;
      background: rgba(13,17,23,0.97);
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 10px 14px;
      min-width: 220px;
      max-width: 290px;
      pointer-events: none;
      box-shadow: 0 4px 24px rgba(0,0,0,0.6);
    }

    /* Prediction card scenarios */
    .pred-scenario { border-radius: 6px; padding: 8px 10px; }

    /* Signal calls table */
    .calls-table { width: 100%; border-collapse: collapse; font-size: 12px; }
    .calls-table th { font-size: 10px; text-transform: uppercase; letter-spacing: .05em;
      color: var(--text-dim); border-bottom: 1px solid #30363d; padding: 4px 8px;
      white-space: nowrap; }
    .calls-table td { padding: 5px 8px; border-bottom: 1px solid #21262d; vertical-align: middle; }
    .calls-table tr:last-child td { border-bottom: none; }
    .calls-btn { font-size: 10px; padding: 2px 7px; border-radius: 4px; border: 1px solid;
      background: transparent; cursor: pointer; margin-right: 3px; white-space: nowrap; }
    .calls-btn.win-btn   { color: #3fb950; border-color: #3fb95066; }
    .calls-btn.win-btn:hover { background: #3fb95022; }
    .calls-btn.loss-btn  { color: #f85149; border-color: #f8514966; }
    .calls-btn.loss-btn:hover { background: #f8514922; }
    .calls-btn.cancel-btn{ color: #8b949e; border-color: #8b949e66; }
    .calls-btn.cancel-btn:hover { background: #8b949e22; }
    .calls-stats-bar { display: flex; gap: 20px; flex-wrap: wrap; padding: 8px 0 12px;
      border-bottom: 1px solid #30363d; margin-bottom: 10px; }
    .calls-stats-bar span { font-size: 12px; }

    /* Post-trade analysis expandable row */
    .pta-row { background: #0d1117; }
    .pta-inner { padding: 10px 14px; font-size: 12px; line-height: 1.7; color: #8b949e; border-left: 3px solid #30363d; margin: 4px 8px; border-radius: 0 4px 4px 0; }
    .pta-inner.win  { border-left-color: #3fb950; }
    .pta-inner.loss { border-left-color: #f85149; }
    .pta-summary  { color: #e6edf3; font-weight: 600; margin-bottom: 6px; }
    .pta-detail   { white-space: pre-wrap; margin-bottom: 6px; }
    .pta-lesson   { color: #d29922; font-style: italic; }
    .pta-chips    { display: flex; gap: 4px; flex-wrap: wrap; margin-top: 6px; }
    .pta-chip     { font-size: 10px; padding: 1px 7px; border-radius: 3px; font-weight: 600; }
    .pta-chip.on  { background: #1a3a1a; color: #3fb950; }
    .pta-chip.off { background: #3a1a1a; color: #f85149; }
    .analysis-toggle { font-size: 10px; color: #58a6ff; cursor: pointer; text-decoration: underline; white-space: nowrap; }

    /* Global all-signals feed */
    #all-signals-section {
      background: var(--bg-card); border-bottom: 1px solid var(--border);
      padding: 10px 16px;
    }
    #all-signals-section.collapsed #all-signals-body { display: none; }
    .asf-header { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 8px; margin-bottom: 8px; }
    .asf-badge { display: inline-flex; align-items: center; gap: 6px; }
    .asf-open-dot { width: 8px; height: 8px; border-radius: 50%; background: #d29922; display: inline-block; animation: pulse 2s ease-in-out infinite; }
    @keyframes pulse { 0%,100% { opacity: 1 } 50% { opacity: .35 } }
    .asf-filter { display: flex; gap: 4px; align-items: center; }
    .asf-filter-btn {
      background: var(--bg-card2); border: 1px solid var(--border); color: #8b949e;
      border-radius: 4px; padding: 2px 10px; font-size: 11px; font-weight: 600;
      cursor: pointer; transition: all .12s;
    }
    .asf-filter-btn:hover  { border-color: var(--blue); color: var(--blue); }
    .asf-filter-btn.active { border-color: var(--blue); color: var(--blue); background: #1a2535; }
    .asf-row-open td { background: rgba(210,153,34,.06); }
    /* Always-visible reason sub-row */
    .asf-reason-row td { padding: 0 8px 6px !important; border-bottom: 1px solid #21262d; }
    .asf-reason-inner {
      display: flex; align-items: center; flex-wrap: wrap; gap: 6px;
      font-size: 11px; color: #8b949e; padding: 2px 0;
    }
    .asf-reason-text  { color: #c9d1d9; }
    .asf-reason-chips { display: flex; gap: 3px; flex-wrap: wrap; }

    .asf-toggle-btn {
      background: none; border: 1px solid var(--border); color: #8b949e;
      border-radius: 4px; padding: 2px 8px; font-size: 11px; cursor: pointer;
    }
    .asf-timer { font-size: 10px; color: #484f58; }

    /* Adaptive learning card */
    .adapt-factor { display: flex; align-items: center; gap: 8px; padding: 4px 0; border-bottom: 1px solid #21262d; font-size: 12px; }
    .adapt-factor:last-child { border-bottom: none; }
    .adapt-bar-track { flex: 1; background: #21262d; border-radius: 3px; height: 6px; overflow: hidden; }
    .adapt-bar-fill  { height: 100%; border-radius: 3px; transition: width .4s; }
    .adapt-log-entry { font-size: 11px; color: #8b949e; padding: 4px 0; border-bottom: 1px solid #21262d; }
    .adapt-log-entry:last-child { border-bottom: none; }
    .adapt-log-ts { font-size: 10px; color: #484f58; }
  </style>
</head>
<body>

<!-- ═══ LOADING OVERLAY ═══ -->
<div id="loading-overlay">
  <div class="spinner"></div>
  <div style="color:#8b949e;font-size:13px" id="loading-msg">Fetching market data...</div>
</div>

<!-- ═══ ERROR BANNER ═══ -->
<div id="error-banner"></div>

<!-- ═══ NAVBAR ═══ -->
<div class="navbar-custom d-flex align-items-center justify-content-between flex-wrap gap-2">
  <div class="d-flex align-items-center gap-2 flex-wrap" id="symbol-bar">
    <!-- symbols rendered by JS -->
  </div>
  <div class="d-flex align-items-center gap-3">
    <span id="timestamp">—</span>
    <button class="sym-btn" onclick="forceRefresh()" title="Force refresh (bypasses cache)">↻ Refresh</button>
    <button class="sym-btn" id="auto-btn" onclick="toggleAuto()">Auto ⏸</button>
    <button class="sym-btn" onclick="openAddSymbol()">+ Add</button>
    <button class="sym-btn" data-bs-toggle="modal" data-bs-target="#methodologyModal" style="border-color:#bc8cff55;color:#bc8cff">? How It Works</button>
  </div>
</div>

<!-- ═══ HERO METRICS ═══ -->
<div class="hero" id="hero-bar">
  <div class="metric"><span class="label">Symbol</span><span class="value" id="h-symbol">—</span></div>
  <div class="metric"><span class="label">Price</span><span class="value" id="h-price">—</span></div>
  <div class="metric"><span class="label">Regime</span><span class="value sm" id="h-regime">—</span></div>
  <div class="metric"><span class="label">Confluence</span><span class="value" id="h-score">—</span></div>
  <div class="metric"><span class="label">RSI (4H)</span><span class="value sm" id="h-rsi">—</span></div>
  <div class="metric"><span class="label">Struct. Bias</span><span class="value sm" id="h-struct">—</span></div>
  <div class="metric"><span class="label">R:R</span><span class="value sm" id="h-rr">—</span></div>
  <div class="metric"><span class="label">ATR (4H)</span><span class="value sm" id="h-atr">—</span></div>
  <div class="metric"><span class="label">200 EMA (Daily)</span><span class="value sm" id="h-ema">—</span></div>
</div>

<!-- ═══ ALL SIGNALS FEED ═══ -->
<div id="all-signals-section">
  <div class="asf-header">
    <div class="asf-badge">
      <span style="font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:.08em;color:#58a6ff">All Signals — Live Feed</span>
      <span id="asf-open-badge"></span>
      <span id="asf-scanner-status" style="font-size:10px;color:#484f58;margin-left:4px"></span>
      <span class="asf-timer" id="asf-timer"></span>
    </div>
    <div class="asf-filter">
      <button class="asf-filter-btn active" id="asf-btn-all"  onclick="filterAllSignals('all')">All</button>
      <button class="asf-filter-btn"        id="asf-btn-open" onclick="filterAllSignals('open')">Open</button>
      <button class="asf-filter-btn"        id="asf-btn-win"  onclick="filterAllSignals('win')">Won</button>
      <button class="asf-filter-btn"        id="asf-btn-loss" onclick="filterAllSignals('loss')">Lost</button>
      <button class="asf-toggle-btn" style="margin-left:4px" onclick="fetchAllSignals()" title="Refresh now">↻</button>
      <button class="asf-toggle-btn" id="asf-collapse-btn" onclick="toggleAllSignals()" title="Collapse/expand">▲</button>
    </div>
  </div>
  <div id="all-signals-body">
    <span style="font-size:13px;color:var(--text-dim)">Loading...</span>
  </div>
</div>

<!-- ═══ CHART ═══ -->
<div class="chart-section">
  <div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-1">
    <div class="chart-legend">
      <span><span class="legend-dot" style="background:#58a6ff;height:1.5px"></span>EMA 50</span>
      <span><span class="legend-dot" style="background:#f0883e;height:2px"></span>EMA 200</span>
      <span><span class="legend-dot" style="background:#3fb950;border-top:1px dashed #3fb950"></span>Support</span>
      <span><span class="legend-dot" style="background:#f85149;border-top:1px dashed #f85149"></span>Resistance</span>
      <span><span class="legend-dot" style="background:#d29922;border-top:1px dotted #d29922"></span>Fib</span>
      <span><span style="color:#3fb950;font-size:12px">▲</span> Long</span>
      <span><span style="color:#f85149;font-size:12px">▼</span> Short</span>
      <span><span class="legend-dot" style="background:#26c6da"></span>OBV</span>
      <span><span class="legend-dot" style="background:#26c6da44"></span>OBV EMA20</span>
    </div>
    <div class="d-flex align-items-center gap-1">
      <span style="font-size:10px;color:#484f58;text-transform:uppercase;letter-spacing:.06em">Timeframe</span>
      <button class="tf-btn" onclick="switchTF('15m',this)">15m</button>
      <button class="tf-btn" onclick="switchTF('1h',this)">1H</button>
      <button class="tf-btn active" onclick="switchTF('4h',this)">4H</button>
      <button class="tf-btn" onclick="switchTF('1d',this)">1D</button>
      <button class="tf-btn" onclick="switchTF('1w',this)">1W</button>
      <span id="tf-label">Analysis: 4H</span>
    </div>
  </div>
  <div id="chart-wrap">
    <div id="main-chart"></div>
    <!-- Signal overlay — top-left of chart -->
    <div id="signal-overlay">
      <div style="font-size:11px;color:#8b949e">Waiting for data...</div>
    </div>
    <!-- Chart line tooltip -->
    <div id="chart-tooltip"></div>
  </div>
  <div style="font-size:10px;color:var(--text-dim);padding:2px 0">RSI (14)</div>
  <div id="rsi-chart"></div>
  <div style="font-size:10px;color:var(--text-dim);padding:2px 0 0">OBV — On Balance Volume &nbsp;<span style="color:#484f58">(teal = OBV · dimmed = 20-EMA)</span></div>
  <div id="obv-chart"></div>
</div>

<!-- ═══ ANALYSIS CARDS — ROW 1 ═══ -->
<div class="card-section">
  <div class="row g-3">

    <!-- SECTION 1: REGIME -->
    <div class="col-xl-4 col-md-6">
      <div class="analysis-card">
        <div class="card-hdr">Section 1 — Market Regime</div>
        <div class="card-body-inner" id="card-regime">
          <div class="text-dim" style="font-size:13px">Loading...</div>
        </div>
      </div>
    </div>

    <!-- SECTION 2: STRUCTURE -->
    <div class="col-xl-4 col-md-6">
      <div class="analysis-card">
        <div class="card-hdr">Section 2 — Structure Analysis (4H)</div>
        <div class="card-body-inner" id="card-structure">
          <div class="text-dim" style="font-size:13px">Loading...</div>
        </div>
      </div>
    </div>

    <!-- SECTION 3: VOLUME & RSI -->
    <div class="col-xl-4 col-md-12">
      <div class="analysis-card">
        <div class="card-hdr">Section 3 — Volume &amp; Momentum</div>
        <div class="card-body-inner" id="card-volume">
          <div class="text-dim" style="font-size:13px">Loading...</div>
        </div>
      </div>
    </div>

  </div>
</div>

<!-- ═══ ANALYSIS CARDS — ROW 2: FIB + VOLATILITY ═══ -->
<div class="card-section" style="padding-top:0">
  <div class="row g-3">

    <!-- SECTION 4: FIBONACCI -->
    <div class="col-xl-6 col-md-6">
      <div class="analysis-card h-100">
        <div class="card-hdr">Section 4 — Fibonacci Retracement</div>
        <div class="card-body-inner" id="card-fib">
          <div class="text-dim" style="font-size:13px">Loading...</div>
        </div>
      </div>
    </div>

    <!-- SECTION 5: VOLATILITY -->
    <div class="col-xl-6 col-md-6">
      <div class="analysis-card h-100">
        <div class="card-hdr">Section 5 — Volatility Filter</div>
        <div class="card-body-inner" id="card-vol2">
          <div class="text-dim" style="font-size:13px">Loading...</div>
        </div>
      </div>
    </div>

  </div>
</div>

<!-- ═══ ANALYSIS CARDS — ROW 3: CONFLUENCE ═══ -->
<div class="card-section" style="padding-top:0">
  <div class="analysis-card">
    <div class="card-hdr">Section 6 — Confluence Score</div>
    <div class="card-body-inner" id="card-confluence">
      <div class="text-dim" style="font-size:13px">Loading...</div>
    </div>
  </div>
</div>

<!-- ═══ SECTION 7: RISK ═══ -->
<div class="card-section" style="padding-top:0;padding-bottom:24px">
  <div class="analysis-card">
    <div class="card-hdr">Section 7 — Risk Context</div>
    <div class="card-body-inner" id="card-risk">
      <div class="text-dim" style="font-size:13px">Loading...</div>
    </div>
  </div>
</div>

<!-- ═══ PRICE PREDICTION ═══ -->
<div class="card-section" style="padding-top:0;padding-bottom:24px">
  <div class="analysis-card">
    <div class="card-hdr">Price Prediction — Near-Term &amp; Swing Targets</div>
    <div class="card-body-inner" id="card-prediction">
      <div class="text-dim" style="font-size:13px">Loading...</div>
    </div>
  </div>
</div>

<!-- ═══ SIGNAL CALLS LOG ═══ -->
<div class="card-section" style="padding-top:0;padding-bottom:24px">
  <div class="analysis-card">
    <div class="card-hdr">
      Signal Log — Tracked Calls
      <span style="font-size:10px;color:#484f58;font-weight:400;margin-left:8px">
        (SQLite · persists across restarts)
      </span>
    </div>
    <div class="card-body-inner" id="card-calls">
      <span class="text-dim" style="font-size:13px">No signals logged yet.</span>
    </div>
  </div>
</div>

<!-- ═══ ADAPTIVE LEARNING ═══ -->
<div class="card-section" style="padding-top:0;padding-bottom:24px">
  <div class="analysis-card">
    <div class="card-hdr">
      Adaptive Learning Engine — Factor Weights &amp; Threshold
      <span style="font-size:10px;color:#484f58;font-weight:400;margin-left:8px">
        auto-adjusts after each trade
      </span>
    </div>
    <div class="card-body-inner" id="card-learning">
      <span class="text-dim" style="font-size:13px">Loading...</span>
    </div>
  </div>
</div>

<!-- ═══ ADD SYMBOL MODAL ═══ -->
<div class="modal fade" id="addModal" tabindex="-1">
  <div class="modal-dialog modal-sm">
    <div class="modal-content">
      <div class="modal-header border-secondary py-2">
        <span class="fw-bold" style="font-size:14px">Add Symbol</span>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <div style="font-size:12px;color:var(--text-dim);margin-bottom:8px">Enter ticker (USDT pair assumed):<br>e.g. SOL, BNB, AVAX</div>
        <input type="text" id="add-input" class="form-control form-control-sm bg-dark border-secondary text-white"
               placeholder="SOL" maxlength="10" style="text-transform:uppercase">
        <div id="add-error" style="color:var(--red);font-size:12px;margin-top:6px;display:none"></div>
      </div>
      <div class="modal-footer border-secondary py-2">
        <button class="sym-btn" onclick="confirmAdd()">Add</button>
      </div>
    </div>
  </div>
</div>

<!-- ═══ METHODOLOGY MODAL ═══ -->
<div class="modal fade method-modal" id="methodologyModal" tabindex="-1">
  <div class="modal-dialog modal-fullscreen">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <div style="font-size:16px;font-weight:700;color:#e6edf3">How It Works — Analysis Methodology</div>
          <div style="font-size:12px;color:#8b949e">Every calculation explained — from raw price data to confluence score</div>
        </div>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body d-flex p-0" style="overflow:hidden;height:100%">

        <!-- Left nav -->
        <div style="width:210px;flex-shrink:0;background:#0d1117;border-right:1px solid #30363d;overflow-y:auto">
          <nav class="method-nav" id="method-nav">
            <div style="font-size:10px;color:#484f58;text-transform:uppercase;letter-spacing:.08em;padding:12px 16px 4px">Sections</div>
            <a href="#m1" onclick="methodNav(this)">1. Market Regime</a>
            <a href="#m2" onclick="methodNav(this)">2. Structure (4H)</a>
            <a href="#m3" onclick="methodNav(this)">3. Volume &amp; OBV</a>
            <a href="#m4" onclick="methodNav(this)">4. RSI</a>
            <a href="#m5" onclick="methodNav(this)">5. Fibonacci</a>
            <a href="#m6" onclick="methodNav(this)">6. Volatility</a>
            <a href="#m7" onclick="methodNav(this)">7. Confluence Score</a>
            <a href="#m8" onclick="methodNav(this)">8. Signal Generation</a>
            <a href="#m9" onclick="methodNav(this)">9. Chart Elements</a>
          </nav>
        </div>

        <!-- Right content -->
        <div id="method-content" style="flex:1;overflow-y:auto;padding:28px 36px;background:#0d1117">

          <!-- §1 MARKET REGIME -->
          <section class="method-section" id="m1">
            <div class="method-title">1. Market Regime</div>
            <p class="method-lead">The daily regime is a top-down filter. Before looking at any 4H entry, the code first classifies what the daily chart is doing. Trading against the daily trend fails more often than it succeeds — the regime tells you which direction has institutional money behind it.</p>

            <div class="method-block">
              <div class="method-block-title">200-Period EMA (Daily)</div>
              <div class="method-formula">k = 2 / (200 + 1) = 0.00995
EMA(today) = Close(today) × k + EMA(yesterday) × (1 − k)</div>
              <p class="method-p">The EMA weights recent candles more heavily than older ones. A 200-bar EMA on the daily chart represents roughly 40 weeks of price memory. Price <strong style="color:#3fb950">above</strong> the 200 EMA = macro bullish context. Price <strong style="color:#f85149">below</strong> = macro bearish. This single level is watched by more institutional desks than almost any other indicator.</p>
            </div>

            <div class="method-block">
              <div class="method-block-title">ATR — Average True Range (14)</div>
              <div class="method-formula">True Range = max( High − Low,  |High − Prev.Close|,  |Low − Prev.Close| )
ATR = 14-period EMA of True Range</div>
              <p class="method-p">ATR captures the full range of price movement including gaps. If price gaps up, the true range from the previous close is larger than just the day's high-low. A rising ATR means increasing volatility — trend conditions. A falling ATR means the market is compressing. ATR is used in two places: the regime (daily ATR) and the volatility filter (4H ATR).</p>
            </div>

            <div class="method-block">
              <div class="method-block-title">Higher Highs / Higher Lows Detection</div>
              <div class="method-formula">Swing High: High[i] = max( High[i−5], ..., High[i+5] )  → 11-bar window
Swing Low:  Low[i]  = min( Low[i−5],  ..., Low[i+5]  )  → 11-bar window
HH/HL = ( SwingHigh₂ > SwingHigh₁ ) AND ( SwingLow₂ > SwingLow₁ )</div>
              <p class="method-p">For every candle, the code checks if its high is the highest point in the surrounding 11-bar window (5 before, 5 after). If yes, it's a swing high. The last two swing highs are compared — if each new swing high is higher than the previous, and each new swing low is higher than the previous, price is making Higher Highs and Higher Lows. That's the textbook definition of an uptrend.</p>
            </div>

            <div class="method-block">
              <div class="method-block-title">Classification Logic</div>
              <table class="method-table">
                <tr><td><span class="method-tag" style="background:#3fb95022;color:#3fb950">Strong Uptrend</span></td><td>Above 200 EMA + HH/HL structure + ATR expanding</td></tr>
                <tr><td><span class="method-tag" style="background:#2ea04322;color:#2ea043">Weak Uptrend</span></td><td>Above 200 EMA + HH/HL structure + ATR contracting</td></tr>
                <tr><td><span class="method-tag" style="background:#f8514922;color:#f85149">Strong Downtrend</span></td><td>Below 200 EMA + LH/LL structure + ATR expanding</td></tr>
                <tr><td><span class="method-tag" style="background:#da363322;color:#da3633">Weak Downtrend</span></td><td>Below 200 EMA + LH/LL structure + ATR contracting</td></tr>
                <tr><td><span class="method-tag" style="background:#d2922222;color:#d29222">Range / Compression</span></td><td>None of the above conditions are satisfied</td></tr>
              </table>
            </div>
          </section>

          <hr class="method-divider">

          <!-- §2 STRUCTURE -->
          <section class="method-section" id="m2">
            <div class="method-title">2. Structure Analysis (4H)</div>
            <p class="method-lead">Structure is the map of where price has been accepted and rejected. Swing highs are where sellers won. Swing lows are where buyers won. A Break of Structure means one side has decisively taken control. Liquidity sweeps are stop hunts — the market briefly fakes a direction, triggers stops, then reverses.</p>

            <div class="method-block">
              <div class="method-block-title">Swing Detection Algorithm</div>
              <div class="method-formula">For each candle at index i (with n=5 lookback):
  Is Swing High? → High[i] == max( High[i−5 : i+5] )
  Is Swing Low?  → Low[i]  == min( Low[i−5  : i+5] )

The last 5 bars cannot be swing points (no future bars to compare yet)</div>
              <p class="method-p">This is a structural pivot detection — not a smoothed indicator. The code scans 200 four-hour candles and marks every local maximum as a swing high and every local minimum as a swing low. The result is the raw price structure with no lag.</p>
            </div>

            <div class="method-block">
              <div class="method-block-title">Break of Structure (BOS)</div>
              <div class="method-formula">Bullish BOS: Current Close > Last Swing High
Bearish BOS: Current Close < Last Swing Low</div>
              <p class="method-p">A BOS is the most important structural event. When price closes beyond the last swing high, it proves buyers have enough force to push through the previous supply zone. This is directional conviction. Without a BOS, any move is just noise inside the existing range. BOS confirmation earns 2 points in the confluence score.</p>
            </div>

            <div class="method-block">
              <div class="method-block-title">Liquidity Sweep Detection</div>
              <div class="method-formula">Bullish Sweep: Low[i] < Swing Low AND Close[i] > Swing Low
  → wick pierced below, then rejected upward (stops taken, bulls step in)

Bearish Sweep: High[i] > Swing High AND Close[i] < Swing High
  → wick pierced above, then rejected downward (stops taken, bears step in)

Checked against last 4 swing points within the last 12 bars</div>
              <p class="method-p">Retail stops cluster below swing lows and above swing highs. Market makers know this. A sweep is when price briefly wicks through those levels — triggering the stops — then reverses hard. The sweep itself creates trapped traders whose forced exits fuel the next move. A sweep before a BOS is the highest-quality setup in this framework.</p>
            </div>

            <div class="method-block">
              <div class="method-block-title">Key Levels</div>
              <p class="method-p"><strong style="color:#3fb950">Support zones</strong> = the last 2 swing lows on 4H. These are where buyers have demonstrated willingness to absorb selling. <strong style="color:#f85149">Resistance zones</strong> = the last 2 swing highs. These are supply areas where sellers stepped in. Both are shown as dashed lines on the chart.</p>
            </div>
          </section>

          <hr class="method-divider">

          <!-- §3 VOLUME & OBV -->
          <section class="method-section" id="m3">
            <div class="method-title">3. Volume &amp; OBV</div>
            <p class="method-lead">Price can be manipulated in low-volume conditions. Volume confirms that real money is participating in a move. OBV (On Balance Volume) is a running total of volume flow that reveals whether smart money is accumulating or distributing while price appears stable.</p>

            <div class="method-block">
              <div class="method-block-title">On Balance Volume (OBV)</div>
              <div class="method-formula">If Close > Prev.Close:  OBV = OBV + Volume   (buyers in control, add volume)
If Close < Prev.Close:  OBV = OBV − Volume   (sellers in control, subtract)
If Close = Prev.Close:  OBV = OBV             (unchanged)

OBV is a running cumulative sum from bar 1</div>
              <p class="method-p">OBV was developed by Joseph Granville in 1963. The idea: volume precedes price. If OBV is rising while price is flat, large buyers are quietly accumulating. If OBV is falling while price holds steady, distribution is happening. When price eventually moves, OBV already told you which direction.</p>
            </div>

            <div class="method-block">
              <div class="method-block-title">OBV Divergence</div>
              <div class="method-formula">Bearish Divergence: Price[last] > Price[20 bars ago] AND OBV[last] ≤ OBV[20 bars ago]
  → Price making new highs but volume flow is not confirming → hidden selling

Bullish Divergence: Price[last] < Price[20 bars ago] AND OBV[last] ≥ OBV[20 bars ago]
  → Price making new lows but volume flow is not confirming → hidden buying</div>
              <p class="method-p">Divergence is the most powerful signal OBV generates. If price prints a new high but OBV doesn't, it means the up-move happened on lower and lower volume — sellers are absorbing the buying pressure. The trend is running out of fuel.</p>
            </div>

            <div class="method-block">
              <div class="method-block-title">Volume Expansion</div>
              <div class="method-formula">Expanding = Average(Volume[last 5 bars]) > Average(Volume[bars −20 to −5])
Spike     = Any bar in last 10 has Volume > 2× Average(last 20 bars)</div>
              <p class="method-p">Volume expansion on a directional move means real participation. A spike (2× average) often marks capitulation (at lows) or breakout (at highs). Volume contracting on a move is a warning — the move may not sustain.</p>
            </div>
          </section>

          <hr class="method-divider">

          <!-- §4 RSI -->
          <section class="method-section" id="m4">
            <div class="method-title">4. RSI — Relative Strength Index</div>
            <p class="method-lead">RSI measures the speed and magnitude of price changes. It answers: is this asset overbought (run up too fast) or oversold (sold off too hard)? More importantly, when RSI diverges from price, it signals that momentum is fading before price confirms it.</p>

            <div class="method-block">
              <div class="method-block-title">RSI Formula (14-period)</div>
              <div class="method-formula">Average Gain = 14-period EMA of gains (bars where Close > Prev.Close)
Average Loss = 14-period EMA of losses (bars where Close < Prev.Close)

RS  = Average Gain / Average Loss
RSI = 100 − ( 100 / (1 + RS) )</div>
              <p class="method-p">RSI output is always 0–100. The EMA smoothing means recent bars weight more than older ones. A reading of 70+ is conventionally overbought — price has risen quickly. 30 or below is oversold. But in strong trends, RSI can stay above 60 or below 40 for extended periods — this is the "bullish range" and "bearish range" concept.</p>
            </div>

            <div class="method-block">
              <div class="method-block-title">Range Classification</div>
              <table class="method-table">
                <tr><td><span class="method-tag" style="background:#3fb95022;color:#3fb950">Bullish Range</span></td><td>RSI &gt; 60 — momentum aligned with upward bias, trend continuation more likely</td></tr>
                <tr><td><span class="method-tag" style="background:#8b949e22;color:#8b949e">Neutral</span></td><td>RSI 40–60 — no directional momentum conviction, range or transitioning</td></tr>
                <tr><td><span class="method-tag" style="background:#f8514922;color:#f85149">Bearish Range</span></td><td>RSI &lt; 40 — momentum aligned with downward bias, trend continuation more likely</td></tr>
              </table>
            </div>

            <div class="method-block">
              <div class="method-block-title">RSI Divergence (14-bar lookback)</div>
              <div class="method-formula">Bearish: Close[last] > max(Close[−14:−1]) AND RSI[last] ≤ max(RSI[−14:−1])
  → Price new high, RSI lower high = momentum fading on up-move

Bullish: Close[last] < min(Close[−14:−1]) AND RSI[last] ≥ min(RSI[−14:−1])
  → Price new low, RSI higher low = momentum fading on down-move</div>
              <p class="method-p">Divergence means price and momentum disagree. In a healthy uptrend, each new price high should come with an RSI high. When they diverge — price new high but RSI lower high — it reveals that each rally takes more effort to achieve and less is accomplished. Trend exhaustion signal.</p>
            </div>

            <div class="method-block">
              <div class="method-block-title">Reset from Extreme</div>
              <div class="method-formula">Reset from Overbought: RSI was ≥70 in last 8 bars AND RSI now &lt; 70
Reset from Oversold:  RSI was ≤30 in last 8 bars AND RSI now &gt; 30</div>
              <p class="method-p">A reset from an extreme is often a better entry signal than the extreme itself. RSI touching 30 and bouncing back above 30 is more actionable than just RSI being at 30 — it shows the selling pressure is actually exhausting and buyers are stepping in.</p>
            </div>
          </section>

          <hr class="method-divider">

          <!-- §5 FIBONACCI -->
          <section class="method-section" id="m5">
            <div class="method-title">5. Fibonacci Retracement</div>
            <p class="method-lead">Fibonacci levels are only applied when the daily regime is trending. In choppy or ranging conditions, there is no clear swing to measure and the levels become noise. In a trend, price rarely goes straight — it pulls back, finds support at predictable mathematical levels, then continues.</p>

            <div class="method-block">
              <div class="method-block-title">How Levels Are Calculated</div>
              <div class="method-formula">Measure from: Last Swing Low → Last Swing High (for uptrend)
Range = Swing High − Swing Low

0.236 level = Swing High − (0.236 × Range)
0.382 level = Swing High − (0.382 × Range)
0.500 level = Swing High − (0.500 × Range)   ← midpoint
0.618 level = Swing High − (0.618 × Range)   ← golden ratio
0.786 level = Swing High − (0.786 × Range)</div>
              <p class="method-p">These ratios derive from the Fibonacci sequence (0, 1, 1, 2, 3, 5, 8, 13...) where each number divided by the next approaches 0.618. The golden ratio appears throughout nature, architecture, and financial markets — not because of mysticism but because enough participants use these levels to create self-fulfilling reactions.</p>
            </div>

            <div class="method-block">
              <div class="method-block-title">Which Levels Matter Most</div>
              <table class="method-table">
                <tr><td><span class="method-tag" style="background:#ffd70022;color:#ffd700">0.382</span></td><td>Shallow retracement — strong trend, momentum intact. Bulls buying early.</td></tr>
                <tr><td><span class="method-tag" style="background:#ffc04022;color:#ffc040">0.500</span></td><td>50% retrace — psychological midpoint. Even split between bulls and bears.</td></tr>
                <tr><td><span class="method-tag" style="background:#ffaa0022;color:#ffaa00">0.618</span></td><td>Golden ratio — most significant level. Deepest pullback in a healthy trend. Highest confluence for long entries.</td></tr>
              </table>
            </div>

            <div class="method-block">
              <div class="method-block-title">Confluence Check</div>
              <div class="method-formula">Price is "at a fib level" if: |Current Price − Fib Level| / Current Price &lt; 1.5%</div>
              <p class="method-p">A fib level alone is weak. A fib level that aligns with a 4H structure support zone — where the swing low also sits near 0.618 — that's confluence. The more independent factors pointing to the same price area, the higher the probability of a reaction there. This combination earns 1 point in the confluence score.</p>
            </div>
          </section>

          <hr class="method-divider">

          <!-- §6 VOLATILITY -->
          <section class="method-section" id="m6">
            <div class="method-title">6. Volatility Filter</div>
            <p class="method-lead">ATR on the 4H chart tells you whether the market is moving enough to trade. Entering during compression (low ATR) is dangerous — the eventual expansion often triggers stops before the real move starts. Entering during expansion means you're joining momentum, not fighting accumulation.</p>

            <div class="method-block">
              <div class="method-block-title">ATR Ratio</div>
              <div class="method-formula">ATR Ratio = Current ATR(14) / Average of ATR over last 20 bars

Expanding:   Ratio &gt; 1.0  → volatility increasing, breakout conditions
Normal:      Ratio 0.7–1.0 → average conditions
Compressing: Ratio &lt; 0.7  → market coiling, fakeout risk elevated</div>
              <p class="method-p">Compression phases (ATR ratio below 0.7) often precede large directional moves, but the direction is unknown until the move starts. Trading breakouts from compression has a high fakeout rate — the market tests both sides before committing. The filter flags this risk explicitly.</p>
            </div>

            <div class="method-block">
              <div class="method-block-title">Practical Implication</div>
              <p class="method-p">If ATR is expanding and you have confluence, the setup is live — you're entering into an active market. If ATR is compressing but confluence is high, the setup is valid but consider waiting for ATR expansion before entering. A tight stop in a compressing market is likely to get hit before the move.</p>
            </div>
          </section>

          <hr class="method-divider">

          <!-- §7 CONFLUENCE SCORE -->
          <section class="method-section" id="m7">
            <div class="method-title">7. Confluence Score (0–10)</div>
            <p class="method-lead">The score combines seven independent signals. Each signal is checked separately — no single indicator drives the whole score. The logic: if five different systems from different methodologies (trend, structure, volume, momentum, price levels) all agree, the probability of a sustained move is materially higher than if only one signal fires.</p>

            <div class="method-block">
              <div class="method-block-title">Scoring Criteria</div>
              <table class="method-table">
                <tr>
                  <td><span class="method-tag" style="background:#58a6ff22;color:#58a6ff">+2 pts</span> Daily Trend Aligned</td>
                  <td>Regime is any Uptrend or Downtrend (not Range). Directional bias exists at the macro level.</td>
                </tr>
                <tr>
                  <td><span class="method-tag" style="background:#58a6ff22;color:#58a6ff">+2 pts</span> Break of Structure</td>
                  <td>4H close above last swing high (bullish) or below last swing low (bearish). Structural proof of direction.</td>
                </tr>
                <tr>
                  <td><span class="method-tag" style="background:#58a6ff22;color:#58a6ff">+2 pts</span> Liquidity Sweep</td>
                  <td>A sweep of swing high/low in last 12 bars. Stop hunt completed — trapped traders fuel the next move.</td>
                </tr>
                <tr>
                  <td><span class="method-tag" style="background:#3fb95022;color:#3fb950">+1 pt</span> Volume Expanding</td>
                  <td>5-bar avg volume exceeds the prior 15-bar avg. Real participation behind the move.</td>
                </tr>
                <tr>
                  <td><span class="method-tag" style="background:#3fb95022;color:#3fb950">+1 pt</span> OBV Divergence</td>
                  <td>Price and OBV disagree over the last 20 bars. Hidden accumulation or distribution detected.</td>
                </tr>
                <tr>
                  <td><span class="method-tag" style="background:#3fb95022;color:#3fb950">+1 pt</span> RSI Confirmation</td>
                  <td>RSI in bullish range (>60) with uptrend, bearish range (<40) with downtrend, or reset from extreme.</td>
                </tr>
                <tr>
                  <td><span class="method-tag" style="background:#3fb95022;color:#3fb950">+1 pt</span> Fib + Structure</td>
                  <td>Price within 1.5% of a key fib level (0.382, 0.5, 0.618). Only scored in trending regimes.</td>
                </tr>
              </table>
            </div>

            <div class="method-block">
              <div class="method-block-title">Score Thresholds</div>
              <table class="method-table">
                <tr><td><span class="method-tag" style="background:#3fb95022;color:#3fb950">7–10 High Probability</span></td><td>Multiple independent systems agree. Structurally sound setup. Execute with proper risk management.</td></tr>
                <tr><td><span class="method-tag" style="background:#d2922222;color:#d29222">5–6 Moderate</span></td><td>Partial agreement. Some factors missing. Size down or wait for additional confirmation.</td></tr>
                <tr><td><span class="method-tag" style="background:#f8514922;color:#f85149">0–4 Avoid</span></td><td>Conflicting or insufficient signals. No trade. Wait for a cleaner setup.</td></tr>
              </table>
            </div>

            <div class="method-block">
              <div class="method-block-title">Why These Specific Criteria?</div>
              <p class="method-p">The 3 two-point criteria (trend, BOS, sweep) are the structural foundation — without at least 2 of these, there's no tradeable thesis. The 4 one-point criteria are confirmation layers. A score of 7 requires at minimum the structural foundation (4–6 pts from the big three) plus confirmation signals. This filters out low-quality setups where one indicator fires but everything else disagrees.</p>
            </div>
          </section>

          <hr class="method-divider">

          <!-- §8 SIGNAL -->
          <section class="method-section" id="m8">
            <div class="method-title">8. Signal Generation</div>
            <p class="method-lead">A signal is only generated when two conditions are simultaneously met: confluence score ≥ 7 AND a confirmed Break of Structure. Score alone is not enough — there must be structural proof of direction. BOS alone is not enough — there must be multi-factor confluence.</p>

            <div class="method-block">
              <div class="method-block-title">Signal Trigger Conditions</div>
              <div class="method-formula">Signal fires when ALL of these are true:
  1. Confluence Score ≥ 7
  2. Bullish BOS (for LONG) OR Bearish BOS (for SHORT)

Direction:
  LONG  → Bullish BOS confirmed (price closed above last swing high)
  SHORT → Bearish BOS confirmed (price closed below last swing low)</div>
            </div>

            <div class="method-block">
              <div class="method-block-title">Entry, Target, Stop Calculation</div>
              <div class="method-formula">Entry  = Current price at the time the signal fires

LONG signal:
  Target       = Last Swing High (nearest resistance to clear)
  Stop (Inval) = Last Swing Low  (structure is broken if price goes here)

SHORT signal:
  Target       = Last Swing Low  (nearest support to tag)
  Stop (Inval) = Last Swing High (structure is broken if price goes here)

R:R = |Target − Entry| / |Entry − Stop|
Signal marked "favorable" if R:R ≥ 2.0</div>
              <p class="method-p">The target and stop are structure-based, not arbitrary. The stop is placed where the structural thesis is definitively wrong. If you're long because of a bullish BOS, the thesis breaks if price closes back below the last swing low — that means the BOS failed and bears are back in control.</p>
            </div>

            <div class="method-block">
              <div class="method-block-title">What No Signal Means</div>
              <p class="method-p">When the overlay box shows "No high-confluence setup," it does not mean the market is about to crash or rally in the other direction. It means: the current conditions don't meet the threshold for a structured entry. Most of the time, markets are in between setups. Waiting is a position.</p>
            </div>
          </section>

          <hr class="method-divider">

          <!-- §9 CHART ELEMENTS -->
          <section class="method-section" id="m9">
            <div class="method-title">9. Chart Elements Key</div>
            <p class="method-lead">Every line on the chart has a specific meaning. Nothing is decorative.</p>

            <div class="method-block">
              <div class="method-block-title">Lines on Price Chart</div>
              <table class="method-table">
                <tr><td><span style="color:#58a6ff">━ EMA 50 (blue)</span></td><td>50-period EMA on the currently selected timeframe. Short-term dynamic support/resistance.</td></tr>
                <tr><td><span style="color:#f0883e">━ EMA 200 (orange)</span></td><td>200-period EMA on the currently selected timeframe. Long-term trend baseline.</td></tr>
                <tr><td><span style="color:#3fb950">- - S (green dashed)</span></td><td>Last 2 major swing lows on 4H. Key support zones — where buyers previously stepped in.</td></tr>
                <tr><td><span style="color:#f85149">- - R (red dashed)</span></td><td>Last 2 major swing highs on 4H. Key resistance zones — where sellers previously stepped in.</td></tr>
                <tr><td><span style="color:#ffd700">··· F0.618 (gold dotted)</span></td><td>Fibonacci retracement levels (0.382, 0.5, 0.618). Only shown in trending regimes.</td></tr>
                <tr><td><span style="color:#ff4444">━ ✖ Inval (solid red)</span></td><td>Invalidation level. If price closes beyond this, the current thesis is structurally broken.</td></tr>
                <tr><td><span style="color:#44ff88">━ ⊕ Target (solid green)</span></td><td>Next target — the level price reaches if the bias plays out correctly.</td></tr>
                <tr><td><span style="color:#3fb950">▲ (green arrow)</span></td><td>Long signal marker on the bar where score ≥ 7 + Bullish BOS was confirmed.</td></tr>
                <tr><td><span style="color:#f85149">▼ (red arrow)</span></td><td>Short signal marker on the bar where score ≥ 7 + Bearish BOS was confirmed.</td></tr>
              </table>
            </div>

            <div class="method-block">
              <div class="method-block-title">RSI Chart (below main chart)</div>
              <table class="method-table">
                <tr><td><span style="color:#bc8cff">━ RSI line (purple)</span></td><td>14-period RSI calculated on the selected timeframe's closing prices.</td></tr>
                <tr><td><span style="color:#f85149">··· 70 (red dotted)</span></td><td>Overbought threshold. RSI above = price has risen quickly, potential exhaustion.</td></tr>
                <tr><td><span style="color:#484f58">··· 50 (gray dotted)</span></td><td>Midline. Bullish regime: RSI holds above 50. Bearish regime: RSI holds below 50.</td></tr>
                <tr><td><span style="color:#3fb950">··· 30 (green dotted)</span></td><td>Oversold threshold. RSI below = price has fallen quickly, potential exhaustion.</td></tr>
              </table>
            </div>

            <div class="method-block">
              <div class="method-block-title">Timeframe Switcher</div>
              <p class="method-p">The TF buttons (15m / 1H / 4H / 1D / 1W) change the <em>chart view only</em>. The analysis cards, confluence score, and signal are always calculated on 4H (primary) with Daily (trend filter). Switching to 15m lets you see 4H structure levels on a granular chart — useful for timing entries after a confluence signal fires.</p>
            </div>
          </section>

        </div><!-- end right content -->
      </div><!-- end modal-body -->
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
<script>
// ═══════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════
let currentSymbol  = 'BTCUSDT';
let symbolList     = JSON.parse(localStorage.getItem('cryptoDashSymbols') || '["BTCUSDT","ETHUSDT","XRPUSDT","DOGEUSDT"]');
let autoRefreshOn  = false;
let autoTimer      = null;
let mainChart      = null;
let rsiChart       = null;
let obvChart       = null;
let seriesMap      = {};
let priceLines       = [];
let addModal         = null;
let lastSignal       = null;
let lastData         = null;  // full analysis response, used for manual close price
let lineContext      = [];   // [{price, label, why, candle_time, color, type}]
let permanentMarkers = [];   // always-visible pivot arrows
let highlightActive  = false;
let lastHighlightTs  = null;

// All-signals feed state
let allSignalsData     = [];
let allSignalsFilter   = 'all';
let allSignalsCollapsed= false;
let asfCountdown       = 60;
let asfCountdownTimer  = null;

// ═══════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════
document.addEventListener('DOMContentLoaded', () => {
  addModal = new bootstrap.Modal(document.getElementById('addModal'));
  initCharts();
  renderSymbolBar();
  loadAnalysis(currentSymbol);
  fetchAllSignals();
  startAsfCountdown();
});

// ═══════════════════════════════════════════════════════
// CHART SETUP
// ═══════════════════════════════════════════════════════
function chartOptions(height) {
  return {
    layout: { background: { color: '#0d1117' }, textColor: '#8b949e' },
    grid:   { vertLines: { color: '#1c2128' }, horzLines: { color: '#1c2128' } },
    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
    rightPriceScale: { borderColor: '#30363d' },
    timeScale: { borderColor: '#30363d', timeVisible: true, secondsVisible: false },
    width: document.getElementById('main-chart').clientWidth,
    height: height,
  };
}

function initCharts() {
  const mainEl = document.getElementById('main-chart');
  const rsiEl  = document.getElementById('rsi-chart');

  mainChart = LightweightCharts.createChart(mainEl, chartOptions(480));

  seriesMap.candles = mainChart.addCandlestickSeries({
    upColor:        '#3fb950', downColor:       '#f85149',
    borderUpColor:  '#3fb950', borderDownColor: '#f85149',
    wickUpColor:    '#3fb950', wickDownColor:   '#f85149',
  });

  seriesMap.vol = mainChart.addHistogramSeries({
    priceFormat:  { type: 'volume' },
    priceScaleId: 'vol',
    color: '#26a69a',
  });
  mainChart.priceScale('vol').applyOptions({ scaleMargins: { top: 0.82, bottom: 0 } });

  seriesMap.ema50 = mainChart.addLineSeries({
    color: '#58a6ff', lineWidth: 1, title: 'EMA50',
    priceLineVisible: false, lastValueVisible: false,
  });
  seriesMap.ema200 = mainChart.addLineSeries({
    color: '#f0883e', lineWidth: 1.5, title: 'EMA200',
    priceLineVisible: false, lastValueVisible: false,
  });

  seriesMap.channelUpper = mainChart.addLineSeries({
    color: '#ffd70066', lineWidth: 1,
    lineStyle: LightweightCharts.LineStyle.Dashed,
    priceLineVisible: false, lastValueVisible: false,
  });
  seriesMap.channelLower = mainChart.addLineSeries({
    color: '#ffd70066', lineWidth: 1,
    lineStyle: LightweightCharts.LineStyle.Dashed,
    priceLineVisible: false, lastValueVisible: false,
  });

  // RSI chart
  rsiChart = LightweightCharts.createChart(rsiEl, {
    ...chartOptions(110),
    timeScale: { borderColor: '#30363d', timeVisible: true, visible: false },
  });
  seriesMap.rsi = rsiChart.addLineSeries({
    color: '#bc8cff', lineWidth: 1.5,
    priceLineVisible: false, lastValueVisible: true, title: 'RSI',
  });
  [[70,'#f85149'],[50,'#30363d'],[30,'#3fb950']].forEach(([p, c]) => {
    seriesMap.rsi.createPriceLine({
      price: p, color: c, lineWidth: 1,
      lineStyle: LightweightCharts.LineStyle.Dotted,
      axisLabelVisible: true, title: String(p),
    });
  });

  // OBV chart
  const obvEl = document.getElementById('obv-chart');
  obvChart = LightweightCharts.createChart(obvEl, {
    ...chartOptions(80),
    timeScale: { borderColor: '#30363d', timeVisible: true, visible: false },
  });
  seriesMap.obv = obvChart.addLineSeries({
    color: '#26c6da', lineWidth: 1.5,
    priceLineVisible: false, lastValueVisible: true, title: 'OBV',
  });
  seriesMap.obv_ema = obvChart.addLineSeries({
    color: '#26c6da44', lineWidth: 1,
    priceLineVisible: false, lastValueVisible: false,
  });

  // Sync all three timescales
  let syncing = false;
  mainChart.timeScale().subscribeVisibleLogicalRangeChange(range => {
    if (range && !syncing) {
      syncing = true;
      rsiChart.timeScale().setVisibleLogicalRange(range);
      obvChart.timeScale().setVisibleLogicalRange(range);
      syncing = false;
    }
  });
  rsiChart.timeScale().subscribeVisibleLogicalRangeChange(range => {
    if (range && !syncing) {
      syncing = true;
      mainChart.timeScale().setVisibleLogicalRange(range);
      obvChart.timeScale().setVisibleLogicalRange(range);
      syncing = false;
    }
  });
  obvChart.timeScale().subscribeVisibleLogicalRangeChange(range => {
    if (range && !syncing) {
      syncing = true;
      mainChart.timeScale().setVisibleLogicalRange(range);
      rsiChart.timeScale().setVisibleLogicalRange(range);
      syncing = false;
    }
  });

  // Responsive resize
  const ro = new ResizeObserver(() => {
    const w = mainEl.clientWidth;
    mainChart.applyOptions({ width: w });
    rsiChart.applyOptions({ width: w });
    obvChart.applyOptions({ width: w });
  });
  ro.observe(mainEl);

  initTooltip();
}

function updateChartData(chart, signal) {
  // ── Price scale reset: clear all data first so switching BTC→XRP auto-scales ──
  priceLines.forEach(pl => { try { seriesMap.candles.removePriceLine(pl); } catch(e){} });
  priceLines = [];
  seriesMap.candles.setData([]);
  seriesMap.vol.setData([]);
  seriesMap.ema50.setData([]);
  seriesMap.ema200.setData([]);
  seriesMap.rsi.setData([]);
  seriesMap.obv.setData([]);
  seriesMap.obv_ema.setData([]);
  if (seriesMap.channelUpper) seriesMap.channelUpper.setData([]);
  if (seriesMap.channelLower) seriesMap.channelLower.setData([]);
  mainChart.priceScale('right').applyOptions({ autoScale: true });
  rsiChart.priceScale('right').applyOptions({ autoScale: true });
  obvChart.priceScale('right').applyOptions({ autoScale: true });

  // ── Set fresh data ──
  seriesMap.candles.setData(chart.candles);
  seriesMap.vol.setData(chart.volume);
  seriesMap.ema50.setData(chart.ema50);
  seriesMap.ema200.setData(chart.ema200);
  seriesMap.rsi.setData(chart.rsi);
  if (chart.obv)     seriesMap.obv.setData(chart.obv);
  if (chart.obv_ema) seriesMap.obv_ema.setData(chart.obv_ema);

  // ── Channel trendlines ──
  if (chart.channels && chart.channels.upper_line) {
    if (seriesMap.channelUpper) seriesMap.channelUpper.setData(chart.channels.upper_line);
    if (seriesMap.channelLower) seriesMap.channelLower.setData(chart.channels.lower_line || []);
  }

  const lvl = chart.levels;

  (lvl.support || []).forEach(p => {
    priceLines.push(seriesMap.candles.createPriceLine({
      price: p, color: '#3fb950', lineWidth: 1,
      lineStyle: LightweightCharts.LineStyle.Dashed,
      axisLabelVisible: true, title: 'S',
    }));
  });

  (lvl.resistance || []).forEach(p => {
    priceLines.push(seriesMap.candles.createPriceLine({
      price: p, color: '#f85149', lineWidth: 1,
      lineStyle: LightweightCharts.LineStyle.Dashed,
      axisLabelVisible: true, title: 'R',
    }));
  });

  const fibColors = {'0.382':'#ffd700','0.5':'#ffc040','0.618':'#ffaa00'};
  Object.entries(lvl.fib || {}).forEach(([k, p]) => {
    if (['0.382','0.5','0.618'].includes(k)) {
      priceLines.push(seriesMap.candles.createPriceLine({
        price: p, color: fibColors[k], lineWidth: 1,
        lineStyle: LightweightCharts.LineStyle.SparseDotted,
        axisLabelVisible: true, title: `F${k}`,
      }));
    }
  });

  if (lvl.invalidation) {
    priceLines.push(seriesMap.candles.createPriceLine({
      price: lvl.invalidation, color: '#ff4444', lineWidth: 1,
      lineStyle: LightweightCharts.LineStyle.Solid,
      axisLabelVisible: true, title: '✖ Inval',
    }));
  }
  if (lvl.target) {
    priceLines.push(seriesMap.candles.createPriceLine({
      price: lvl.target, color: '#44ff88', lineWidth: 1,
      lineStyle: LightweightCharts.LineStyle.Solid,
      axisLabelVisible: true, title: '⊕ Target',
    }));
  }

  mainChart.timeScale().fitContent();
}

// ═══════════════════════════════════════════════════════
// DATA LOADING
// ═══════════════════════════════════════════════════════
async function loadAnalysis(symbol, forceRefresh = false) {
  showLoading(`Fetching ${symbol}...`);
  hideError();
  try {
    const tf = currentTF;
    const endpoint = forceRefresh
      ? `/api/refresh/${symbol}/${tf}`
      : `/api/analysis/${symbol}/${tf}`;
    const resp = await fetch(endpoint);
    const data = await resp.json();
    if (data.error) throw new Error(data.error);
    renderAll(data);
  } catch(e) {
    showError(`Failed to load ${symbol}: ${e.message}`);
  } finally {
    hideLoading();
  }
}

function forceRefresh() { loadAnalysis(currentSymbol, true); }

// ═══════════════════════════════════════════════════════
// RENDER ALL
// ═══════════════════════════════════════════════════════
function renderAll(d) {
  lastData   = d;
  lastSignal = d.signal;
  updateChartData(d.chart, d.signal);
  buildLineContext(d);
  buildPivotMarkers(d);
  setMarkersWithSignal(d.signal);
  renderHero(d);
  renderSignal(d.signal);
  renderRegime(d.regime);
  renderStructure(d.structure, d.swings, d.sweeps, d.key_support, d.key_resistance, d.channels, d.interval);
  renderVolume(d.volume, d.rsi);
  renderFib(d.fibonacci);
  renderVolatility(d.volatility);
  renderConfluence(d.confluence);
  renderRisk(d.risk, d.confluence);
  renderPrediction(d.prediction);
  setTimestamp(d.fetched_at, d.cache_age);
  fetchTrades();
}

// ═══════════════════════════════════════════════════════
// HERO BAR
// ═══════════════════════════════════════════════════════
function renderHero(d) {
  const sym = d.symbol.replace('USDT','');
  const r   = d.regime;
  const c   = d.confluence;
  const rsk = d.risk;

  set('h-symbol', sym, regimeColor(r.regime));
  set('h-price',  '$' + fmt(d.current_price));
  set('h-regime', r.regime, regimeColor(r.regime));

  const sc = c.score;
  const scColor = sc >= 7 ? '#3fb950' : sc >= 5 ? '#d29922' : '#f85149';
  set('h-score', `${sc}/10`, scColor);

  const rsiC = d.rsi.range === 'Bullish' ? '#3fb950' : d.rsi.range === 'Bearish' ? '#f85149' : '#8b949e';
  set('h-rsi', `${d.rsi.value} (${d.rsi.range})`, rsiC);

  let biasText = 'No BOS';
  let biasColor = '#8b949e';
  if (d.structure) {
    if (d.structure.bullish_bos) { biasText = 'Bullish BOS'; biasColor = '#3fb950'; }
    else if (d.structure.bearish_bos) { biasText = 'Bearish BOS'; biasColor = '#f85149'; }
    else if (d.structure.hh_hl) { biasText = 'HH/HL'; biasColor = '#3fb950'; }
    else if (d.structure.lh_ll) { biasText = 'LH/LL'; biasColor = '#f85149'; }
  }
  set('h-struct', biasText, biasColor);
  set('h-rr', rsk.rr + ':1', rsk.favorable ? '#3fb950' : '#d29922');
  set('h-atr', '$' + fmt(d.volatility.current), d.volatility.expanding ? '#3fb950' : '#d29922');
  set('h-ema', '$' + fmt(r.ema200), r.above_200 ? '#3fb950' : '#f85149');
}

// ═══════════════════════════════════════════════════════
// SECTION 1: REGIME
// ═══════════════════════════════════════════════════════
function renderRegime(r) {
  const color = regimeColor(r.regime);
  const patt = r.hh_hl ? 'HH / HL' : r.lh_ll ? 'LH / LL' : 'Mixed / Unclear';
  const pattC = r.hh_hl ? '#3fb950' : r.lh_ll ? '#f85149' : '#d29922';

  document.getElementById('card-regime').innerHTML = `
    <div class="badge-regime" style="background:${color}22;color:${color};border:1px solid ${color}44">
      ${r.regime}
    </div>
    ${row('Price vs 200 EMA (Daily)',
      `${yn(r.above_200,'Above','Below')} &nbsp;<span class="text-dim">($${fmt(r.ema200)})</span>`)}
    ${row('Price Structure', `<span style="color:${pattC}">${patt}</span>`)}
    ${row('Daily ATR', `$${fmt(r.atr)} — ${r.atr_expanding
      ? '<span class="text-g">Expanding</span>'
      : '<span class="text-y">Contracting</span>'}`)}
    ${row('Trend Filter', r.above_200
      ? '<span class="text-g">Bullish context (above 200 EMA)</span>'
      : '<span class="text-r">Bearish context (below 200 EMA)</span>')}
  `;
}

// ═══════════════════════════════════════════════════════
// SECTION 2: STRUCTURE
// ═══════════════════════════════════════════════════════
function renderStructure(s, swings, sweeps, support, resistance, channels, interval) {
  const tfLabel = (interval || '4H').toUpperCase();
  let bosHtml = '<span class="text-dim">No confirmed BOS</span>';
  if (s) {
    if (s.bullish_bos) bosHtml = '<span class="text-g fw-bold">Bullish BOS — price closed above last swing high</span>';
    else if (s.bearish_bos) bosHtml = '<span class="text-r fw-bold">Bearish BOS — price closed below last swing low</span>';
  }

  const shList = (swings.highs || []).slice(-3).reverse().map((x,i) =>
    `<div class="swing-item">
      <span class="text-dim">SH${i===0?'(last)':''}</span>
      <span class="text-r fw-bold">$${fmt(x[1])}</span>
      <span class="text-dim" style="font-size:10px">${fmtDate(x[0])}</span>
    </div>`).join('');

  const slList = (swings.lows || []).slice(-3).reverse().map((x,i) =>
    `<div class="swing-item">
      <span class="text-dim">SL${i===0?'(last)':''}</span>
      <span class="text-g fw-bold">$${fmt(x[1])}</span>
      <span class="text-dim" style="font-size:10px">${fmtDate(x[0])}</span>
    </div>`).join('');

  const sweepHtml = sweeps && sweeps.length
    ? sweeps.slice(0,3).map(sw =>
        `<span class="sweep-pill" style="background:${sw.type.includes('bull')?'#3fb95022':'#f8514922'};color:${sw.type.includes('bull')?'#3fb950':'#f85149'};border:1px solid ${sw.type.includes('bull')?'#3fb95044':'#f8514944'}">
          ${sw.type === 'bullish_sweep' ? '↑' : '↓'} $${fmt(sw.level)}
        </span>`).join('')
    : '<span class="text-dim" style="font-size:12px">None detected</span>';

  const supHtml = support.length
    ? support.map(p => `<span class="level-pill" style="background:#3fb95022;color:#3fb950;border:1px solid #3fb95044">$${fmt(p)}</span>`).join('')
    : '<span class="text-dim">—</span>';
  const resHtml = resistance.length
    ? resistance.map(p => `<span class="level-pill" style="background:#f8514922;color:#f85149;border:1px solid #f8514944">$${fmt(p)}</span>`).join('')
    : '<span class="text-dim">—</span>';

  let channelHtml = '<span class="text-dim">None detected</span>';
  if (channels && channels.channel_type) {
    const cColor = channels.bias === 'Bullish' ? '#3fb950' : channels.bias === 'Bearish' ? '#f85149' : '#8b949e';
    channelHtml = `<span style="color:${cColor};font-weight:600">${channels.channel_type}</span>`
      + `<span class="text-dim" style="font-size:11px;margin-left:6px">${channels.note}</span>`;
  }

  document.getElementById('card-structure').innerHTML = `
    ${row('Break of Structure', bosHtml)}
    ${row('Pattern', s ? (s.hh_hl ? '<span class="text-g">Higher Highs / Higher Lows</span>' : s.lh_ll ? '<span class="text-r">Lower Highs / Lower Lows</span>' : '<span class="text-y">Mixed</span>') : '<span class="text-dim">—</span>')}
    ${row('Channel', channelHtml)}
    ${row('Liquidity Sweeps', sweepHtml)}
    ${row('Key Support', supHtml)}
    ${row('Key Resistance', resHtml)}
    <div style="margin-top:10px">
      <div style="font-size:10px;color:var(--text-dim);text-transform:uppercase;letter-spacing:.06em;margin-bottom:4px">Swing Highs (${tfLabel})</div>
      <div class="swing-list">${shList || '<span class="text-dim" style="font-size:12px">Insufficient data</span>'}</div>
    </div>
    <div style="margin-top:8px">
      <div style="font-size:10px;color:var(--text-dim);text-transform:uppercase;letter-spacing:.06em;margin-bottom:4px">Swing Lows (${tfLabel})</div>
      <div class="swing-list">${slList || '<span class="text-dim" style="font-size:12px">Insufficient data</span>'}</div>
    </div>
  `;
}

// ═══════════════════════════════════════════════════════
// SECTION 3: VOLUME & RSI
// ═══════════════════════════════════════════════════════
function renderVolume(v, r) {
  const divHtml = v.bullish_obv_div
    ? '<span class="text-g">Bullish OBV divergence — price lower, OBV higher</span>'
    : v.bearish_obv_div
    ? '<span class="text-r">Bearish OBV divergence — price higher, OBV lower</span>'
    : '<span class="text-dim">No divergence</span>';

  const rsiDivHtml = r.bullish_div
    ? '<span class="text-g">Bullish RSI divergence detected</span>'
    : r.bearish_div
    ? '<span class="text-r">Bearish RSI divergence detected</span>'
    : '<span class="text-dim">None</span>';

  const rsiResetHtml = r.reset_oversold
    ? '<span class="text-g">Reset from oversold (&lt;30)</span>'
    : r.reset_overbought
    ? '<span class="text-y">Reset from overbought (&gt;70)</span>'
    : '<span class="text-dim">No recent extreme</span>';

  const rsiColor = r.range === 'Bullish' ? '#3fb950' : r.range === 'Bearish' ? '#f85149' : '#8b949e';
  const rsiExtreme = r.overbought ? ' <span style="color:#f85149;font-size:11px">OVERBOUGHT</span>'
                   : r.oversold   ? ' <span style="color:#3fb950;font-size:11px">OVERSOLD</span>' : '';

  document.getElementById('card-volume').innerHTML = `
    <div style="font-size:10px;color:var(--text-dim);text-transform:uppercase;letter-spacing:.06em;margin-bottom:6px">Volume</div>
    ${row('Trend', v.expanding
      ? '<span class="text-g">Expanding — participation increasing</span>'
      : '<span class="text-y">Declining — weak participation</span>')}
    ${row('Recent Spike', yn(v.recent_spike, '2x+ avg in last 10 bars', 'No spike'))}
    ${row('OBV Direction', v.obv_bullish
      ? '<span class="text-g">Bullish — OBV trending up</span>'
      : '<span class="text-r">Bearish — OBV trending down</span>')}
    ${row('OBV Divergence', divHtml)}
    <div style="font-size:10px;color:var(--text-dim);text-transform:uppercase;letter-spacing:.06em;margin:10px 0 6px">RSI (14) — 4H</div>
    ${row('Value', `<span style="color:${rsiColor};font-weight:700;font-size:16px">${r.value}</span>${rsiExtreme}`)}
    ${row('Range', `<span style="color:${rsiColor}">${r.range}</span>`)}
    ${row('Divergence', rsiDivHtml)}
    ${row('Extreme Reset', rsiResetHtml)}
  `;
}

// ═══════════════════════════════════════════════════════
// SECTION 4: FIBONACCI
// ═══════════════════════════════════════════════════════
function renderFib(fib) {
  if (!fib) {
    document.getElementById('card-fib').innerHTML =
      '<span class="text-dim" style="font-size:13px">Fibonacci not applied — regime is Range / Compression. Fib is only calculated in trending conditions.</span>';
    return;
  }

  const rows = Object.entries(fib.levels).map(([k, v]) => {
    const isNearest = k === fib.nearest_level;
    const isKey = ['0.382','0.5','0.618'].includes(k);
    const cls = isNearest && fib.at_fib ? 'fib-row active' : 'fib-row';
    const labelColor = k === '0.0' || k === '1.0' ? '#8b949e' : isKey ? '#d29922' : '#6e7681';
    return `<div class="${cls}">
      <span style="color:${labelColor}">${k === '0.0' ? 'Swing Low (0.0)' : k === '1.0' ? 'Swing High (1.0)' : `${k} Retrace`}</span>
      <span style="color:${isNearest && fib.at_fib ? '#d29922' : '#e6edf3'};font-weight:${isNearest && fib.at_fib ? '700' : '400'}">
        $${fmt(v)} ${isNearest && fib.at_fib ? '← HERE' : ''}
      </span>
    </div>`;
  }).join('');

  document.getElementById('card-fib').innerHTML = `
    <div style="font-size:11px;color:var(--text-dim);margin-bottom:8px">
      Swing: $${fmt(fib.swing_low)} → $${fmt(fib.swing_high)}
    </div>
    ${rows}
    <div style="margin-top:10px;font-size:12px">
      ${fib.at_fib
        ? `<span class="text-y">Price within 1.5% of Fib ${fib.nearest_level} ($${fmt(fib.nearest_price)}) — confluence zone</span>`
        : `<span class="text-dim">Nearest level: ${fib.nearest_level} at $${fmt(fib.nearest_price)} (${fib.distance_pct}% away)</span>`}
    </div>
  `;
}

// ═══════════════════════════════════════════════════════
// SECTION 5: VOLATILITY
// ═══════════════════════════════════════════════════════
function renderVolatility(v) {
  const ratio = (v.current / v.avg).toFixed(2);
  document.getElementById('card-vol2').innerHTML = `
    ${row('ATR (4H)', `$${fmt(v.current)}`)}
    ${row('ATR 20-bar avg', `$${fmt(v.avg)}`)}
    ${row('ATR Ratio', `${ratio}x avg — ${v.expanding
      ? '<span class="text-g">Expanding — breakout potential</span>'
      : v.compressing
      ? '<span class="text-r">Compressed — fakeout risk elevated</span>'
      : '<span class="text-y">Normal range</span>'}`)}
    ${row('Breakout Risk', v.compressing
      ? '<span class="text-r">High fakeout risk — wait for expansion</span>'
      : v.expanding
      ? '<span class="text-g">Low fakeout risk — expansion underway</span>'
      : '<span class="text-dim">Moderate</span>')}
  `;
}

// ═══════════════════════════════════════════════════════
// SECTION 6: CONFLUENCE
// ═══════════════════════════════════════════════════════
function renderConfluence(c) {
  const pct   = (c.score / c.max) * 100;
  const color = c.score >= 7 ? '#3fb950' : c.score >= 5 ? '#d29922' : '#f85149';
  const strLabel = c.score >= 7 ? 'HIGH PROBABILITY' : c.score >= 5 ? 'MODERATE SETUP' : 'LOW QUALITY';

  const reasonsHtml = c.reasons.map(r => `
    <div class="conf-reason">
      <div class="conf-dot" style="background:${r.earned ? '#3fb950' : '#30363d'};border:1px solid ${r.earned ? '#3fb950' : '#484f58'}"></div>
      <div>
        <span style="color:${r.earned ? '#3fb950' : '#8b949e'};font-weight:${r.earned ? '600' : '400'}">${r.earned ? '+' : ''}${r.pts} pts</span>
        <span style="color:${r.earned ? '#e6edf3' : '#6e7681'};margin-left:6px">${r.text}</span>
      </div>
    </div>`).join('');

  const improveHtml = c.improve && c.improve.length
    ? c.improve.map(t => `<div style="font-size:12px;color:#8b949e;padding:2px 0">→ ${t}</div>`).join('')
    : '<div style="font-size:12px;color:#3fb950">All factors satisfied</div>';

  document.getElementById('card-confluence').innerHTML = `
    <div class="d-flex align-items-center gap-4 mb-3">
      <div>
        <div class="score-badge" style="color:${color}">${c.score}<span style="font-size:18px;color:#8b949e">/${c.max}</span></div>
        <div class="score-label" style="color:${color}">${strLabel}</div>
      </div>
      <div style="flex:1">
        <div class="conf-bar-wrap">
          <div class="conf-bar-fill" style="width:${pct}%;background:${color}"></div>
        </div>
        <div style="font-size:12px;color:#8b949e;margin-top:4px">${c.strength}</div>
      </div>
    </div>
    <div>${reasonsHtml}</div>
    ${c.improve && c.score < 10 ? `
    <div style="margin-top:12px;border-top:1px solid #21262d;padding-top:10px">
      <div style="font-size:10px;color:#8b949e;text-transform:uppercase;letter-spacing:.06em;margin-bottom:6px">What would improve this setup</div>
      ${improveHtml}
    </div>` : ''}
  `;
}

// ═══════════════════════════════════════════════════════
// SECTION 7: RISK
// ═══════════════════════════════════════════════════════
function renderRisk(rsk, c) {
  const biasColor = rsk.bias === 'Long' ? '#3fb950' : rsk.bias === 'Short' ? '#f85149' : '#8b949e';
  const rrColor   = rsk.favorable ? '#3fb950' : '#d29922';

  document.getElementById('card-risk').innerHTML = `
    <div class="row g-3">
      <div class="col-md-6">
        ${row('Directional Bias', `<span style="color:${biasColor};font-weight:700">${rsk.bias}</span>`)}
        ${row('Current Price', `<span class="fw-bold">$${fmt(rsk.current)}</span>`)}
        ${row('Invalidation Level', `<span class="text-r fw-bold">$${fmt(rsk.invalidation)}</span>`)}
        ${row('Next Target', `<span class="text-g fw-bold">$${fmt(rsk.target)}</span>`)}
        ${row('R:R Ratio', `<span style="color:${rrColor};font-weight:700;font-size:16px">${rsk.rr}:1</span> ${rsk.favorable ? '<span class="text-g" style="font-size:11px">✓ FAVORABLE</span>' : '<span class="text-y" style="font-size:11px">⚠ BELOW 2:1</span>'}`)}
      </div>
      <div class="col-md-6">
        <div style="font-size:10px;color:var(--text-dim);text-transform:uppercase;letter-spacing:.06em;margin-bottom:8px">Invalidation Condition</div>
        <div style="font-size:13px;color:#e6edf3;padding:8px 10px;background:#21262d;border-radius:6px;border-left:3px solid #f85149">
          ${rsk.invalidation_note}
        </div>
        ${c.improve && c.improve.length ? `
        <div style="font-size:10px;color:var(--text-dim);text-transform:uppercase;letter-spacing:.06em;margin:12px 0 6px">What would invalidate setup</div>
        <div style="font-size:12px;color:#8b949e;padding:8px 10px;background:#21262d;border-radius:6px">
          <div>→ ${rsk.invalidation_note}</div>
          <div>→ Daily regime shifts from current classification</div>
          <div>→ Volume collapses on directional move</div>
        </div>` : ''}
      </div>
    </div>
  `;
}

// ═══════════════════════════════════════════════════════
// SIGNAL OVERLAY
// ═══════════════════════════════════════════════════════
function renderSignal(sig) {
  const el = document.getElementById('signal-overlay');
  if (!sig) {
    el.className = 'no-signal';
    el.style.borderColor = '#21262d';
    el.innerHTML = `
      <div style="font-size:10px;color:#484f58;text-transform:uppercase;letter-spacing:.06em;margin-bottom:3px">Signal</div>
      <div style="font-size:12px;color:#6e7681">No high-confluence setup<br>Score below 7/10</div>`;
    return;
  }

  const isLong  = sig.direction === 'LONG';
  const color   = isLong ? '#3fb950' : '#f85149';
  const arrow   = isLong ? '▲' : '▼';
  const rrColor = sig.favorable ? '#3fb950' : '#d29922';

  el.className = '';
  el.style.display = 'block';
  el.style.borderColor = color + '55';
  el.innerHTML = `
    <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
      <span style="color:${color};font-size:18px;font-weight:800;line-height:1">${arrow} ${sig.direction}</span>
      <span style="background:${color}22;color:${color};border:1px solid ${color}44;border-radius:4px;padding:1px 7px;font-size:11px;font-weight:700">${sig.score}/10</span>
    </div>
    <div style="display:grid;grid-template-columns:42px auto;gap:3px 10px;font-size:12px;margin-bottom:8px">
      <span style="color:#8b949e">Entry</span>
      <span style="color:#e6edf3;font-weight:600">$${fmt(sig.entry)}</span>
      <span style="color:#8b949e">Target</span>
      <span style="color:#3fb950;font-weight:600">$${fmt(sig.target)}</span>
      <span style="color:#8b949e">Stop</span>
      <span style="color:#f85149;font-weight:600">$${fmt(sig.stop)}</span>
      <span style="color:#8b949e">R:R</span>
      <span style="color:${rrColor};font-weight:700">${sig.rr}:1 ${sig.favorable ? '✓' : '⚠'}</span>
    </div>
    <div style="font-size:10px;color:#8b949e;border-top:1px solid #21262d;padding-top:6px;line-height:1.4">
      ${sig.reason}
    </div>
    ${sig.top_reasons.length ? `
    <div style="margin-top:6px">
      ${sig.top_reasons.slice(0,3).map(r =>
        `<div style="font-size:10px;color:#6e7681;padding:1px 0">· ${r}</div>`
      ).join('')}
    </div>` : ''}
  `;
}

// ═══════════════════════════════════════════════════════
// PIVOT MARKERS & SIGNAL MARKERS
// ═══════════════════════════════════════════════════════
function buildPivotMarkers(d) {
  permanentMarkers = [];
  const swingHighs = d.swings.highs || [];
  const swingLows  = d.swings.lows  || [];

  swingHighs.forEach(([ts]) => {
    const t = Math.floor(new Date(ts).getTime() / 1000);
    permanentMarkers.push({ time: t, position: 'aboveBar', color: '#f8514955', shape: 'arrowDown', size: 1, text: '' });
  });
  swingLows.forEach(([ts]) => {
    const t = Math.floor(new Date(ts).getTime() / 1000);
    permanentMarkers.push({ time: t, position: 'belowBar', color: '#3fb95055', shape: 'arrowUp', size: 1, text: '' });
  });

  permanentMarkers.sort((a, b) => a.time - b.time);
}

function setMarkersWithSignal(signal) {
  let markers = [...permanentMarkers];
  if (signal) {
    const isLong = signal.direction === 'LONG';
    markers.push({
      time: signal.bar_time,
      position: isLong ? 'belowBar' : 'aboveBar',
      color: isLong ? '#3fb950' : '#f85149',
      shape: isLong ? 'arrowUp' : 'arrowDown',
      text: `${signal.direction}  ${signal.score}/10`,
      size: 2,
    });
    markers.sort((a, b) => a.time - b.time);
  }
  try { seriesMap.candles.setMarkers(markers); } catch(e) {}
}

function showHighlightMarker(lineInfo) {
  const times = lineInfo.candle_times || [];
  if (times.length === 0) {
    if (highlightActive) clearHighlightMarker();
    return;
  }

  // Skip re-render if same level already highlighted
  const key = times[0];
  if (highlightActive && lastHighlightTs === key) return;
  lastHighlightTs = key;
  highlightActive = true;

  const isAbove = lineInfo.type === 'resistance' || lineInfo.type === 'invalidation' || lineInfo.type === 'ema200';
  const pos = isAbove ? 'aboveBar' : 'belowBar';

  // Build circle markers: first touch = white/large, subsequent = colored/smaller
  const highlights = times.map((t, i) => ({
    time: t,
    position: pos,
    color: i === 0 ? '#ffffff' : lineInfo.color + 'bb',
    shape: 'circle',
    size: i === 0 ? 2 : 1.5,
    text: '',
  }));

  let markers = [...permanentMarkers, ...highlights];
  if (lastSignal) {
    const isLong = lastSignal.direction === 'LONG';
    markers.push({
      time: lastSignal.bar_time,
      position: isLong ? 'belowBar' : 'aboveBar',
      color: isLong ? '#3fb950' : '#f85149',
      shape: isLong ? 'arrowUp' : 'arrowDown',
      text: `${lastSignal.direction}  ${lastSignal.score}/10`,
      size: 2,
    });
  }
  markers.sort((a, b) => a.time - b.time);
  try { seriesMap.candles.setMarkers(markers); } catch(e) {}
}

function clearHighlightMarker() {
  if (!highlightActive) return;
  highlightActive = false;
  lastHighlightTs = null;
  setMarkersWithSignal(lastSignal);
}

// ═══════════════════════════════════════════════════════
// CHART LINE TOOLTIPS
// ═══════════════════════════════════════════════════════
function buildLineContext(d) {
  lineContext = [];
  if (!d || !d.chart) return;
  const lvl = d.chart.levels;
  const tf = (d.interval || '4H').toUpperCase();

  // ── Support zones (with touch timestamps from Python) ──
  (lvl.support || []).forEach((p) => {
    const touches = (lvl.support_touches && lvl.support_touches[String(p)]) || [];
    const n = touches.length;
    const bos = d.structure && d.structure.bullish_bos && d.risk && p === d.risk.invalidation;
    lineContext.push({
      price: p, label: 'Support Zone', color: '#3fb950', type: 'support',
      candle_times: touches,
      why: `${tf} swing low at $${fmt(p)}. `
         + (n >= 2
            ? `${n} candle touches detected — price has bounced from this level multiple times, confirming structural support.`
            : 'Buyers stepped in here, pushing price back up. Watch for reactions on any retest.')
         + (bos ? ' This level also serves as the trade invalidation.' : ''),
    });
  });

  // ── Resistance zones ──
  (lvl.resistance || []).forEach((p) => {
    const touches = (lvl.resistance_touches && lvl.resistance_touches[String(p)]) || [];
    const n = touches.length;
    const bos = d.structure && d.structure.bearish_bos && d.risk && p === d.risk.invalidation;
    lineContext.push({
      price: p, label: 'Resistance Zone', color: '#f85149', type: 'resistance',
      candle_times: touches,
      why: `${tf} swing high at $${fmt(p)}. `
         + (n >= 2
            ? `${n} candle touches detected — sellers have stepped in here repeatedly, confirming structural resistance.`
            : 'Sellers stepped in here, pushing price back down. Watch for rejections on any retest.')
         + (bos ? ' This level also serves as the trade invalidation.' : ''),
    });
  });

  // ── Fibonacci levels ──
  const fib = d.fibonacci;
  const fibDesc = {
    '0.382': '38.2% retracement — shallow pullback in a strong trend. Bulls buying early, momentum intact.',
    '0.5':   '50% retracement — the psychological midpoint. Equal split; strong level if price holds here.',
    '0.618': '61.8% — the golden ratio. Deepest healthy retracement. Highest-confluence fib for long entries.',
  };
  if (fib) {
    Object.entries(fib.levels).forEach(([k, p]) => {
      if (['0.382','0.5','0.618'].includes(k)) {
        lineContext.push({
          price: p, label: `Fib ${k}`, type: 'fib',
          color: {'0.382':'#ffd700','0.5':'#ffc040','0.618':'#ffaa00'}[k],
          candle_times: [],
          why: `${fibDesc[k]} Measured from swing low $${fmt(fib.swing_low)} → swing high $${fmt(fib.swing_high)}.`,
        });
      }
    });
  }

  // ── Invalidation ──
  if (lvl.invalidation) {
    const bias = d.risk ? d.risk.bias : 'Neutral';
    lineContext.push({
      price: lvl.invalidation, label: 'Invalidation', color: '#ff4444', type: 'invalidation',
      candle_times: [],
      why: `A ${tf} close ${bias === 'Long' ? 'below' : 'above'} this level structurally breaks the ${bias.toLowerCase()} thesis. `
         + `This is the last swing ${bias === 'Long' ? 'low' : 'high'} — once price closes beyond it, the setup is invalid.`,
    });
  }

  // ── Swing target ──
  if (lvl.target) {
    const bias = d.risk ? d.risk.bias : 'Neutral';
    lineContext.push({
      price: lvl.target, label: 'Swing Target', color: '#44ff88', type: 'target',
      candle_times: [],
      why: `Next structural objective — the last swing ${bias === 'Long' ? 'high (prior resistance)' : 'low (prior support)'}. `
         + `If the ${bias.toLowerCase()} setup plays out, price should reach this level. R:R = ${d.risk ? d.risk.rr : '?'}:1.`,
    });
  }

  // ── EMA 50 (add current value so hovering near it shows tooltip) ──
  if (d.chart.ema50 && d.chart.ema50.length > 0) {
    const v = d.chart.ema50[d.chart.ema50.length - 1].value;
    const above = d.current_price > v;
    lineContext.push({
      price: v, label: 'EMA 50', color: '#58a6ff', type: 'ema50',
      candle_times: [],
      why: `50-period EMA = $${fmt(v)} on this timeframe. `
         + `Price is currently ${above ? 'above' : 'below'} — ${above ? 'short-term bullish momentum. Acts as dynamic support; watch for bounces on retests.' : 'short-term bearish pressure. Acts as dynamic resistance; watch for rejections on retests.'}`,
    });
  }

  // ── EMA 200 ──
  if (d.chart.ema200 && d.chart.ema200.length > 0) {
    const v = d.chart.ema200[d.chart.ema200.length - 1].value;
    const above = d.current_price > v;
    lineContext.push({
      price: v, label: 'EMA 200', color: '#f0883e', type: 'ema200',
      candle_times: [],
      why: `200-period EMA = $${fmt(v)} on this timeframe. `
         + `Price is ${above ? 'above' : 'below'} the long-term baseline. `
         + `${above ? 'Institutional buyers are generally positioned long above this level.' : 'Institutional players are generally positioned short below this level.'} `
         + 'The most-watched EMA by professional desks.',
    });
  }
}

function initTooltip() {
  const wrap    = document.getElementById('chart-wrap');
  const tooltip = document.getElementById('chart-tooltip');
  const CHART_H = 480; // main chart pixel height

  wrap.addEventListener('mousemove', (e) => {
    const rect   = wrap.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    if (mouseY > CHART_H || lineContext.length === 0) {
      tooltip.style.display = 'none';
      clearHighlightMarker();
      return;
    }

    let closest = null;
    let minDist = 9; // px threshold

    lineContext.forEach(info => {
      try {
        const lineY = seriesMap.candles.priceToCoordinate(info.price);
        if (lineY !== null) {
          const dist = Math.abs(mouseY - lineY);
          if (dist < minDist) { minDist = dist; closest = info; }
        }
      } catch(_) {}
    });

    if (closest) {
      showTooltip(closest, mouseX, mouseY, rect);
      showHighlightMarker(closest);
    } else {
      tooltip.style.display = 'none';
      clearHighlightMarker();
    }
  });

  wrap.addEventListener('mouseleave', () => {
    tooltip.style.display = 'none';
    clearHighlightMarker();
  });
}

function showTooltip(info, mouseX, mouseY, wrapRect) {
  const tooltip = document.getElementById('chart-tooltip');
  const times = info.candle_times || [];
  const n = times.length;

  // Show oldest touch (creator) date + count
  const primaryTs = n > 0 ? times[0] : null;
  const dateStr = primaryTs
    ? new Date(primaryTs * 1000).toLocaleDateString('en-US',
        { month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' })
    : null;

  tooltip.innerHTML = `
    <div style="font-size:10px;font-weight:700;color:${info.color};text-transform:uppercase;letter-spacing:.07em;margin-bottom:4px">${info.label}</div>
    <div style="font-size:14px;font-weight:700;color:#e6edf3;margin-bottom:6px">$${fmt(info.price)}</div>
    <div style="font-size:12px;color:#8b949e;line-height:1.55">${info.why}</div>
    ${dateStr ? `
    <div style="font-size:10px;color:#484f58;border-top:1px solid #21262d;padding-top:6px;margin-top:6px">
      First touched: ${dateStr}${n > 1 ? ` &nbsp;·&nbsp; <span style="color:${info.color}">${n} touches ◉ shown</span>` : ' &nbsp;<span style="color:#bc8cff">◉ highlighted</span>'}
    </div>` : ''}
  `;

  tooltip.style.display = 'block';
  const ttW = tooltip.offsetWidth;
  const ttH = tooltip.offsetHeight;
  const W   = wrapRect.width;
  const H   = 480;

  let tx = mouseX + 18;
  let ty = mouseY - Math.floor(ttH / 2);
  if (tx + ttW > W - 8)  tx = mouseX - ttW - 14;
  if (tx < 8)             tx = 8;
  if (ty < 8)             ty = 8;
  if (ty + ttH > H - 8)  ty = H - ttH - 8;

  tooltip.style.left = tx + 'px';
  tooltip.style.top  = ty + 'px';
}

// ═══════════════════════════════════════════════════════
// PRICE PREDICTION CARD
// ═══════════════════════════════════════════════════════
function renderPrediction(pred) {
  const el = document.getElementById('card-prediction');
  if (!pred) {
    el.innerHTML = '<span class="text-dim" style="font-size:13px">No prediction available.</span>';
    return;
  }

  const biasColor = pred.bias === 'Long' ? '#3fb950' : pred.bias === 'Short' ? '#f85149' : '#8b949e';
  const confColor = pred.confidence === 'High' ? '#3fb950' : pred.confidence === 'Medium' ? '#d29922' : '#f85149';
  const nt  = pred.near_term;
  const sw  = pred.swing;
  const sc  = pred.scenarios;

  const ntBullHtml = pred.bias === 'Short'
    ? `<span class="text-dim">$${fmt(nt.bull_target)}</span>`
    : `<span class="text-g fw-bold">$${fmt(nt.bull_target)}</span>`;
  const ntBearHtml = pred.bias === 'Long'
    ? `<span class="text-dim">$${fmt(nt.bear_target)}</span>`
    : `<span class="text-r fw-bold">$${fmt(nt.bear_target)}</span>`;

  el.innerHTML = `
    <div class="row g-3">
      <div class="col-lg-8">
        <div style="font-size:13px;color:#8b949e;line-height:1.7;border-left:3px solid ${biasColor}44;padding-left:12px">
          ${pred.narrative}
        </div>
      </div>
      <div class="col-lg-4">
        <div style="background:#21262d;border-radius:6px;padding:10px 12px;margin-bottom:8px">
          <div style="font-size:10px;color:#484f58;text-transform:uppercase;letter-spacing:.06em;margin-bottom:6px">
            Near-Term (${nt.timeframe})
          </div>
          ${row('Bull target', ntBullHtml)}
          ${row('Bear target', ntBearHtml)}
          ${row('4H ATR', `$${fmt(nt.atr)}`)}
          <div style="font-size:10px;color:#484f58;margin-top:4px">${nt.method}</div>
        </div>
        <div style="background:#21262d;border-radius:6px;padding:10px 12px">
          <div style="font-size:10px;color:#484f58;text-transform:uppercase;letter-spacing:.06em;margin-bottom:6px">
            Swing Structure
          </div>
          ${row('Target', `<span class="text-g fw-bold">$${fmt(sw.target)}</span>`)}
          ${row('Invalidation', `<span class="text-r fw-bold">$${fmt(sw.invalidation)}</span>`)}
          ${sw.extended_target ? row('Extended', `<span style="color:#bc8cff;font-weight:600">$${fmt(sw.extended_target)}</span>`) : ''}
        </div>
      </div>
    </div>

    <div style="margin-top:14px;border-top:1px solid #21262d;padding-top:12px">
      <div style="font-size:10px;color:#484f58;text-transform:uppercase;letter-spacing:.06em;margin-bottom:8px">Scenarios</div>
      <div class="row g-2">
        <div class="col-md-4">
          <div class="pred-scenario" style="background:#3fb95011;border:1px solid #3fb95033">
            <div style="font-size:10px;color:#3fb950;font-weight:700;margin-bottom:4px">BULL</div>
            <div style="font-size:14px;font-weight:700;color:#3fb950">$${fmt(sc.bull.price)}</div>
            <div style="font-size:11px;color:#8b949e;margin-top:3px;line-height:1.4">${sc.bull.condition}</div>
          </div>
        </div>
        <div class="col-md-4">
          <div class="pred-scenario" style="background:#58a6ff11;border:1px solid #58a6ff33">
            <div style="font-size:10px;color:#58a6ff;font-weight:700;margin-bottom:4px">BASE</div>
            <div style="font-size:14px;font-weight:700;color:#58a6ff">$${fmt(sc.base.price)}</div>
            <div style="font-size:11px;color:#8b949e;margin-top:3px;line-height:1.4">${sc.base.condition}</div>
          </div>
        </div>
        <div class="col-md-4">
          <div class="pred-scenario" style="background:#f8514911;border:1px solid #f8514933">
            <div style="font-size:10px;color:#f85149;font-weight:700;margin-bottom:4px">BEAR</div>
            <div style="font-size:14px;font-weight:700;color:#f85149">$${fmt(sc.bear.price)}</div>
            <div style="font-size:11px;color:#8b949e;margin-top:3px;line-height:1.4">${sc.bear.condition}</div>
          </div>
        </div>
      </div>
    </div>
    <div style="margin-top:8px;font-size:11px;color:#484f58">
      Prediction confidence: <span style="color:${confColor};font-weight:700">${pred.confidence}</span>
      — based on confluence score ${pred.bias !== 'Neutral' ? '+ structural BOS confirmation' : '(no directional BOS)'}
    </div>
  `;
}

// ═══════════════════════════════════════════════════════
// SYMBOL MANAGEMENT
// ═══════════════════════════════════════════════════════
function renderSymbolBar() {
  const bar = document.getElementById('symbol-bar');
  bar.innerHTML = symbolList.map(s => {
    const ticker = s.replace('USDT','');
    const isActive = s === currentSymbol;
    const isDefault = ['BTCUSDT','ETHUSDT','XRPUSDT','DOGEUSDT'].includes(s);
    return `
      <div style="display:inline-flex;align-items:center;gap:2px">
        <button class="sym-btn ${isActive?'active':''}" onclick="switchSymbol('${s}')">${ticker}</button>
        ${!isDefault ? `<button class="sym-btn remove" onclick="removeSymbol('${s}')" title="Remove">✕</button>` : ''}
      </div>`;
  }).join('');
}

function switchSymbol(sym) {
  currentSymbol = sym;
  currentTF = '4h';
  document.querySelectorAll('.tf-btn').forEach((b, i) => b.classList.toggle('active', i === 2));
  const label = document.getElementById('tf-label');
  if (label) label.textContent = `Analysis: ${currentTF.toUpperCase()}`;
  renderSymbolBar();
  loadAnalysis(sym);
}

function removeSymbol(sym) {
  symbolList = symbolList.filter(s => s !== sym);
  localStorage.setItem('cryptoDashSymbols', JSON.stringify(symbolList));
  if (currentSymbol === sym) currentSymbol = symbolList[0] || 'BTCUSDT';
  renderSymbolBar();
  if (currentSymbol !== sym) return;
  loadAnalysis(currentSymbol);
}

function openAddSymbol() {
  document.getElementById('add-input').value = '';
  document.getElementById('add-error').style.display = 'none';
  addModal.show();
  setTimeout(() => document.getElementById('add-input').focus(), 300);
}

async function confirmAdd() {
  const val = document.getElementById('add-input').value.trim().toUpperCase();
  if (!val) return;
  const sym = val.endsWith('USDT') ? val : val + 'USDT';
  const errEl = document.getElementById('add-error');
  errEl.style.display = 'none';

  // Quick validity check
  try {
    const r = await fetch(`/api/analysis/${sym}`);
    const d = await r.json();
    if (d.error) throw new Error(d.error);
    if (!symbolList.includes(sym)) {
      symbolList.push(sym);
      localStorage.setItem('cryptoDashSymbols', JSON.stringify(symbolList));
    }
    addModal.hide();
    switchSymbol(sym);
    renderSymbolBar();
  } catch(e) {
    errEl.textContent = `Symbol not found or fetch failed: ${e.message}`;
    errEl.style.display = 'block';
  }
}

document.getElementById('add-input').addEventListener('keydown', e => { if(e.key==='Enter') confirmAdd(); });

// ═══════════════════════════════════════════════════════
// TIMEFRAME SWITCHER
// ═══════════════════════════════════════════════════════
let currentTF = '4h';

async function switchTF(tf, btn) {
  if (tf === currentTF) return;
  currentTF = tf;

  // Update button states
  document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
  if (btn) btn.classList.add('active');

  // Update label
  const label = document.getElementById('tf-label');
  if (label) label.textContent = `Analysis: ${tf.toUpperCase()}`;

  // Full re-analysis on the new timeframe
  await loadAnalysis(currentSymbol);
}

// ═══════════════════════════════════════════════════════
// METHODOLOGY MODAL NAV
// ═══════════════════════════════════════════════════════
function methodNav(el) {
  document.querySelectorAll('.method-nav a').forEach(a => a.classList.remove('active'));
  el.classList.add('active');
}

// Highlight nav item on scroll
document.addEventListener('DOMContentLoaded', () => {
  const contentEl = document.getElementById('method-content');
  if (contentEl) {
    contentEl.addEventListener('scroll', () => {
      const sections = contentEl.querySelectorAll('.method-section');
      let current = null;
      sections.forEach(s => {
        if (s.offsetTop - contentEl.scrollTop <= 60) current = s.id;
      });
      if (current) {
        document.querySelectorAll('.method-nav a').forEach(a => {
          a.classList.toggle('active', a.getAttribute('href') === '#' + current);
        });
      }
    });
  }
});

// ═══════════════════════════════════════════════════════
// ═══════════════════════════════════════════════════════
// ALL SIGNALS GLOBAL FEED
// ═══════════════════════════════════════════════════════
async function fetchAllSignals() {
  try {
    const resp = await fetch('/api/trades');
    allSignalsData = await resp.json();
    renderAllSignals();
    asfCountdown = 60;
  } catch(e) { /* silent */ }
  fetchScannerStatus();
}

async function fetchScannerStatus() {
  try {
    const resp = await fetch('/api/scanner-status');
    const s    = await resp.json();
    const el   = document.getElementById('asf-scanner-status');
    if (!el) return;
    if (!s.running) {
      el.textContent = '· scanner starting...';
      return;
    }
    if (s.last_scan_at) {
      const ago = s.last_scan_ago_s;
      const agoStr = ago < 60 ? `${ago}s ago`
                   : ago < 3600 ? `${Math.round(ago/60)}m ago`
                   : `${Math.round(ago/3600)}h ago`;
      el.textContent = `· scanner ✓ — last scan ${agoStr} · ${s.scans_completed} sweeps · ${s.signals_logged} signals found`;
    } else {
      el.textContent = '· first scan in progress...';
    }
  } catch(e) { /* silent */ }
}

function startAsfCountdown() {
  asfCountdownTimer = setInterval(() => {
    asfCountdown--;
    const el = document.getElementById('asf-timer');
    if (el) el.textContent = `↻ ${asfCountdown}s`;
    if (asfCountdown <= 0) {
      fetchAllSignals();
      asfCountdown = 60;
    }
  }, 1000);
}

function filterAllSignals(f) {
  allSignalsFilter = f;
  ['all','open','win','loss'].forEach(k => {
    const btn = document.getElementById('asf-btn-' + k);
    if (btn) btn.classList.toggle('active', k === f);
  });
  renderAllSignals();
}

function toggleAllSignals() {
  allSignalsCollapsed = !allSignalsCollapsed;
  const sec = document.getElementById('all-signals-section');
  const btn = document.getElementById('asf-collapse-btn');
  if (sec) sec.classList.toggle('collapsed', allSignalsCollapsed);
  if (btn) btn.textContent = allSignalsCollapsed ? '▼' : '▲';
}

function renderAllSignals() {
  const el = document.getElementById('all-signals-body');
  if (!el) return;

  const trades = allSignalsData || [];
  const filtered = allSignalsFilter === 'all'
    ? trades
    : trades.filter(t => t.status === allSignalsFilter);

  // Update open badge
  const openCount = trades.filter(t => t.status === 'open').length;
  const badge = document.getElementById('asf-open-badge');
  if (badge) {
    badge.innerHTML = openCount > 0
      ? `<span class="asf-open-dot"></span><span style="font-size:11px;color:#d29922;font-weight:700">${openCount} open</span>`
      : `<span style="font-size:11px;color:#484f58">no open signals</span>`;
  }

  if (trades.length === 0) {
    el.innerHTML = '<span style="font-size:13px;color:var(--text-dim)">No signals yet. Signals fire when confluence score ≥ threshold and a BOS is confirmed.</span>';
    return;
  }

  // Stats
  const wins   = trades.filter(t => t.status === 'win').length;
  const losses = trades.filter(t => t.status === 'loss').length;
  const closed = wins + losses;
  const wrPct  = closed > 0 ? Math.round(wins / closed * 100) : null;
  const wrColor= wrPct !== null ? (wrPct >= 50 ? '#3fb950' : '#f85149') : '#8b949e';
  const allRois= trades.filter(t => t.roi_pct !== null).map(t => t.roi_pct);
  const totalRoi = allRois.length > 0 ? allRois.reduce((a,b)=>a+b,0).toFixed(1) : null;

  const statsHtml = `<div class="calls-stats-bar" style="padding-top:0;margin-bottom:8px">
    <span><span class="text-dim">Total:</span> <b>${trades.length}</b></span>
    <span><span class="text-dim">Open:</span> <b style="color:#d29922">${openCount}</b></span>
    <span><span class="text-dim">Won:</span> <b style="color:#3fb950">${wins}</b></span>
    <span><span class="text-dim">Lost:</span> <b style="color:#f85149">${losses}</b></span>
    <span><span class="text-dim">Win Rate:</span> <b style="color:${wrColor}">${wrPct !== null ? wrPct + '%' : '—'}</b></span>
    <span><span class="text-dim">Total P&amp;L:</span> <b style="color:${totalRoi !== null && parseFloat(totalRoi) >= 0 ? '#3fb950' : '#f85149'}">${totalRoi !== null ? (parseFloat(totalRoi) >= 0 ? '+' : '') + totalRoi + '%' : '—'}</b></span>
  </div>`;

  if (filtered.length === 0) {
    el.innerHTML = statsHtml + `<span style="font-size:13px;color:var(--text-dim)">No ${allSignalsFilter} signals.</span>`;
    return;
  }

  const rows = filtered.map((t, idx) => {
    const sym       = t.symbol.replace('USDT','');
    const dirColor  = t.direction === 'SHORT' ? '#f85149' : '#3fb950';
    const stColor   = {open:'#d29922',win:'#3fb950',loss:'#f85149',cancelled:'#484f58'}[t.status] || '#8b949e';
    const roiStr    = t.roi_pct !== null ? (t.roi_pct >= 0 ? '+' : '') + t.roi_pct + '%' : '—';
    const roiColor  = t.roi_pct !== null ? (t.roi_pct >= 0 ? '#3fb950' : '#f85149') : '#8b949e';
    const scoreColor= t.score >= 9 ? '#3fb950' : t.score >= 7 ? '#d29922' : '#8b949e';
    const dt        = t.opened_at ? new Date(t.opened_at) : null;
    const dtStr     = dt ? dt.toLocaleDateString([], {month:'short',day:'numeric'}) + ' '
      + dt.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : '—';
    const pta       = t.post_trade_analysis;
    const ptaId     = `asf-pta-${idx}`;
    const isOpen    = t.status === 'open';

    const actions = isOpen
      ? `<button class="calls-btn win-btn"    onclick="closeTrade('${t.id}','win')">✓</button>`
        + `<button class="calls-btn loss-btn"   onclick="closeTrade('${t.id}','loss')">✗</button>`
        + `<button class="calls-btn cancel-btn" onclick="closeTrade('${t.id}','cancelled')">—</button>`
      : `<span style="color:${stColor};font-size:11px;text-transform:uppercase">${t.status}</span>`;

    // Factor chips from signal snapshot
    const snap    = t.factors_snapshot || {};
    const chips   = Object.entries(snap).map(([f, v]) =>
      `<span class="pta-chip ${v ? 'on' : 'off'}">${f}</span>`
    ).join('');

    // Always-visible reason row
    const reason      = t.reason || '';
    const targetBasis = t.target_basis ? `<span style="color:#484f58"> · TP: ${t.target_basis}</span>` : '';
    const reasonRow = `<tr class="asf-reason-row${isOpen ? ' asf-row-open' : ''}">
      <td colspan="10">
        <div class="asf-reason-inner">
          ${reason ? `<span class="asf-reason-text">${reason}</span>${targetBasis}` : '<span style="color:#484f58;font-style:italic">No reason recorded</span>'}
          ${chips ? `<span class="asf-reason-chips">${chips}</span>` : ''}
          ${pta ? `<span class="analysis-toggle" style="margin-left:8px" onclick="togglePTA('${ptaId}')">▸ Post-trade analysis</span>` : ''}
        </div>
      </td>
    </tr>`;

    const mainRow = `<tr class="${isOpen ? 'asf-row-open' : ''}">
      <td><b style="color:#e6edf3">${sym}</b></td>
      <td style="color:#8b949e">${t.interval.toUpperCase()}</td>
      <td style="color:${dirColor};font-weight:700">${t.direction}</td>
      <td>$${fmt(t.entry)}</td>
      <td style="color:#3fb950">$${fmt(t.tp)}</td>
      <td style="color:#f85149">$${fmt(t.sl)}</td>
      <td style="color:${scoreColor}">${t.score}/10</td>
      <td style="color:#8b949e;font-size:10px">${dtStr}</td>
      <td style="color:${roiColor};font-weight:700">${roiStr}</td>
      <td>${actions}</td>
    </tr>`;

    if (!pta) return mainRow + reasonRow;

    const ptaClass = pta.status === 'win' ? 'win' : pta.status === 'loss' ? 'loss' : '';
    const present  = (pta.factors_present||[]).map(f=>`<span class="pta-chip on">${f}</span>`).join('');
    const absent   = (pta.factors_absent ||[]).map(f=>`<span class="pta-chip off">${f}</span>`).join('');

    const ptaRow = `<tr id="${ptaId}" class="pta-row" style="display:none">
      <td colspan="10">
        <div class="pta-inner ${ptaClass}">
          <div class="pta-summary">${pta.summary||''}</div>
          ${pta.detail ? `<div class="pta-detail">${pta.detail}</div>` : ''}
          ${pta.key_lesson ? `<div class="pta-lesson">Key lesson: ${pta.key_lesson}</div>` : ''}
          <div class="pta-chips">${present}${absent}</div>
        </div>
      </td>
    </tr>`;

    return mainRow + reasonRow + ptaRow;
  }).join('');

  el.innerHTML = statsHtml + `<div style="overflow-x:auto">
    <table class="calls-table">
      <thead><tr>
        <th>Symbol</th><th>TF</th><th>Dir</th><th>Entry</th>
        <th>TP</th><th>SL</th><th>Score</th><th>Date</th><th>ROI</th><th>Action</th>
      </tr></thead>
      <tbody>${rows}</tbody>
    </table>
  </div>`;
}

// SIGNAL CALLS LOG
// ═══════════════════════════════════════════════════════
async function fetchTrades() {
  try {
    const resp   = await fetch('/api/trades');
    const trades = await resp.json();
    renderTrades(trades);
    // Keep global feed in sync (same endpoint, reuse data)
    allSignalsData = trades;
    renderAllSignals();
  } catch(e) { /* silent — non-critical */ }
  fetchLearning();
}

async function fetchLearning() {
  try {
    const resp = await fetch('/api/learning');
    const data = await resp.json();
    renderLearning(data);
  } catch(e) { /* silent */ }
}

async function closeTrade(id, status) {
  let price = lastData ? lastData.current_price : null;
  if (status !== 'cancelled') {
    const sym   = lastData ? lastData.symbol.replace('USDT','') : '';
    const label = status === 'win' ? '✓ WIN' : '✗ LOSS';
    const hint  = price ? ` (current: $${fmt(price)})` : '';
    const input = prompt(`${sym} ${label} — exit price?${hint}\nLeave blank to use current price.`, '');
    if (input === null) return; // user pressed Cancel
    if (input.trim()) price = parseFloat(input) || price;
  }
  try {
    await fetch(`/api/trades/${id}/close`, {
      method:  'POST',
      headers: {'Content-Type': 'application/json'},
      body:    JSON.stringify({ status, price }),
    });
    fetchTrades();       // refreshes per-symbol card + global feed + learning
  } catch(e) { showError('Close trade failed: ' + e.message); }
}

function renderTrades(trades) {
  const el = document.getElementById('card-calls');
  if (!el) return;
  if (!trades || trades.length === 0) {
    el.innerHTML = '<span class="text-dim" style="font-size:13px">No signals logged yet. '
      + 'Signals fire when confluence score ≥ threshold and a BOS is confirmed.</span>';
    return;
  }

  const total  = trades.length;
  const open   = trades.filter(t => t.status === 'open').length;
  const wins   = trades.filter(t => t.status === 'win').length;
  const losses = trades.filter(t => t.status === 'loss').length;
  const closed = wins + losses;
  const wrPct  = closed > 0 ? Math.round(wins / closed * 100) : null;
  const wrColor= wrPct !== null ? (wrPct >= 50 ? '#3fb950' : '#f85149') : '#8b949e';
  const wonRois= trades.filter(t => t.status === 'win' && t.roi_pct !== null).map(t => t.roi_pct);
  const avgRoi = wonRois.length > 0
    ? (wonRois.reduce((a,b) => a+b, 0) / wonRois.length).toFixed(1) + '%'
    : '—';
  const allRois= trades.filter(t => t.roi_pct !== null).map(t => t.roi_pct);
  const totalRoi = allRois.length > 0
    ? (allRois.reduce((a,b) => a+b, 0)).toFixed(1) + '%'
    : '—';

  const statsHtml = `
    <div class="calls-stats-bar">
      <span><span class="text-dim">Total:</span> <b>${total}</b></span>
      <span><span class="text-dim">Open:</span> <b style="color:#d29922">${open}</b></span>
      <span><span class="text-dim">Won:</span> <b style="color:#3fb950">${wins}</b></span>
      <span><span class="text-dim">Lost:</span> <b style="color:#f85149">${losses}</b></span>
      <span><span class="text-dim">Win Rate:</span> <b style="color:${wrColor}">${wrPct !== null ? wrPct + '%' : '—'}</b></span>
      <span><span class="text-dim">Avg ROI (wins):</span> <b style="color:#3fb950">${avgRoi !== '—' ? '+' + avgRoi : '—'}</b></span>
      <span><span class="text-dim">Total P&amp;L:</span> <b style="color:${totalRoi !== '—' && parseFloat(totalRoi) >= 0 ? '#3fb950' : '#f85149'}">${totalRoi !== '—' ? (parseFloat(totalRoi) >= 0 ? '+' : '') + totalRoi : '—'}</b></span>
    </div>`;

  const rows = trades.map((t, idx) => {
    const sym      = t.symbol.replace('USDT','');
    const isShort  = t.direction === 'SHORT';
    const dirColor = isShort ? '#f85149' : '#3fb950';
    const stColor  = {open:'#d29922', win:'#3fb950', loss:'#f85149', cancelled:'#484f58'}[t.status] || '#8b949e';
    const roiStr   = t.roi_pct !== null ? (t.roi_pct >= 0 ? '+' : '') + t.roi_pct + '%' : '—';
    const roiColor = t.roi_pct !== null ? (t.roi_pct >= 0 ? '#3fb950' : '#f85149') : '#8b949e';
    const dt       = t.opened_at ? new Date(t.opened_at) : null;
    const dtStr    = dt ? dt.toLocaleDateString() + ' '
      + dt.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : '—';
    const scoreColor = t.score >= 9 ? '#3fb950' : t.score >= 7 ? '#d29922' : '#8b949e';
    const pta        = t.post_trade_analysis;
    const ptaId      = `pta-${idx}`;

    const actions = t.status === 'open'
      ? `<button class="calls-btn win-btn"    onclick="closeTrade('${t.id}','win')">✓ Won</button>`
        + `<button class="calls-btn loss-btn"   onclick="closeTrade('${t.id}','loss')">✗ Lost</button>`
        + `<button class="calls-btn cancel-btn" onclick="closeTrade('${t.id}','cancelled')">— Cancel</button>`
      : `<span style="color:${stColor};font-size:11px;text-transform:uppercase">${t.status}</span>`;

    const analysisToggle = pta
      ? `<span class="analysis-toggle" onclick="togglePTA('${ptaId}')">▸ Analysis</span>`
      : '';

    const mainRow = `<tr>
      <td><b>${sym}</b></td>
      <td style="color:#8b949e">${t.interval.toUpperCase()}</td>
      <td style="color:${dirColor};font-weight:700">${t.direction}</td>
      <td>$${fmt(t.entry)}</td>
      <td style="color:#3fb950">$${fmt(t.tp)}</td>
      <td style="color:#f85149">$${fmt(t.sl)}</td>
      <td style="color:${scoreColor}">${t.score}/10</td>
      <td style="color:#8b949e;font-size:10px">${dtStr}</td>
      <td style="color:${roiColor};font-weight:700">${roiStr}</td>
      <td>${actions} ${analysisToggle}</td>
    </tr>`;

    if (!pta) return mainRow;

    const ptaClass = pta.status === 'win' ? 'win' : pta.status === 'loss' ? 'loss' : '';
    const present = (pta.factors_present || []).map(f => `<span class="pta-chip on">${f}</span>`).join('');
    const absent  = (pta.factors_absent  || []).map(f => `<span class="pta-chip off">${f}</span>`).join('');

    const ptaRow = `<tr id="${ptaId}" class="pta-row" style="display:none">
      <td colspan="10">
        <div class="pta-inner ${ptaClass}">
          <div class="pta-summary">${pta.summary || ''}</div>
          ${pta.detail ? `<div class="pta-detail">${pta.detail}</div>` : ''}
          ${pta.key_lesson ? `<div class="pta-lesson">Key lesson: ${pta.key_lesson}</div>` : ''}
          <div class="pta-chips">${present}${absent}</div>
        </div>
      </td>
    </tr>`;

    return mainRow + ptaRow;
  }).join('');

  el.innerHTML = statsHtml + `
    <div style="overflow-x:auto">
      <table class="calls-table">
        <thead><tr>
          <th>Symbol</th><th>TF</th><th>Dir</th><th>Entry</th>
          <th>TP</th><th>SL</th><th>Score</th><th>Opened</th><th>ROI</th><th>Action</th>
        </tr></thead>
        <tbody>${rows}</tbody>
      </table>
    </div>`;
}

function togglePTA(id) {
  const row = document.getElementById(id);
  if (!row) return;
  const hidden = row.style.display === 'none';
  row.style.display = hidden ? '' : 'none';
  // Update toggle text
  const toggle = row.previousElementSibling &&
    row.previousElementSibling.querySelector('.analysis-toggle');
  if (toggle) toggle.textContent = hidden ? '▾ Analysis' : '▸ Analysis';
}

// ═══════════════════════════════════════════════════════
// ADAPTIVE LEARNING DISPLAY
// ═══════════════════════════════════════════════════════
function renderLearning(data) {
  const el = document.getElementById('card-learning');
  if (!el || !data) return;

  const { weights, signal_threshold, default_threshold, stop_multiplier,
          default_stop_mult, overall_win_rate, total_closed, adaptation_log } = data;

  // Factor weights table
  const factorRows = Object.entries(weights).map(([name, info]) => {
    const pct     = Math.min(100, Math.round(info.ratio * 100));
    const barColor= info.status === 'reduced' ? '#f85149'
                  : info.status === 'boosted' ? '#3fb950' : '#58a6ff';
    const statusBadge = info.status !== 'normal'
      ? `<span style="font-size:10px;color:${barColor};margin-left:4px">(${info.status})</span>`
      : '';
    return `<div class="adapt-factor">
      <span style="width:56px;color:#e6edf3;font-weight:600;text-transform:capitalize">${name}</span>
      <div class="adapt-bar-track">
        <div class="adapt-bar-fill" style="width:${pct}%;background:${barColor}"></div>
      </div>
      <span style="width:72px;text-align:right;color:${barColor}">
        ${info.current.toFixed(2)} <span style="color:#484f58">/ ${info.default.toFixed(1)}</span>
      </span>
      ${statusBadge}
    </div>`;
  }).join('');

  // Global params
  const threshColor  = signal_threshold > default_threshold ? '#d29922' : '#3fb950';
  const stopColor    = stop_multiplier  > default_stop_mult  ? '#d29922' : '#3fb950';
  const wrColor      = overall_win_rate !== null
    ? (overall_win_rate >= 50 ? '#3fb950' : '#f85149') : '#8b949e';

  // Adaptation log
  const logHtml = adaptation_log && adaptation_log.length > 0
    ? adaptation_log.map(entry => {
        const ts = new Date(entry.timestamp).toLocaleString([], {
          month:'short', day:'numeric', hour:'2-digit', minute:'2-digit'
        });
        return `<div class="adapt-log-entry">
          <div class="adapt-log-ts">${ts}</div>
          ${entry.changes.map(c => `<div>${c}</div>`).join('')}
        </div>`;
      }).join('')
    : '<div style="font-size:12px;color:#484f58">No adaptations yet — needs ≥3 closed trades to begin learning.</div>';

  el.innerHTML = `
    <div class="row g-3">
      <div class="col-xl-5 col-md-6">
        <div style="font-size:10px;color:var(--text-dim);text-transform:uppercase;letter-spacing:.06em;margin-bottom:8px">
          Factor Weights (current / default)
        </div>
        ${factorRows}
      </div>
      <div class="col-xl-3 col-md-6">
        <div style="font-size:10px;color:var(--text-dim);text-transform:uppercase;letter-spacing:.06em;margin-bottom:8px">
          Adaptive Parameters
        </div>
        <div class="info-row">
          <span class="info-label">Signal Threshold</span>
          <span class="info-val" style="color:${threshColor}">${signal_threshold.toFixed(1)}
            <span style="color:#484f58;font-size:10px">/ ${default_threshold.toFixed(1)} default</span>
          </span>
        </div>
        <div class="info-row">
          <span class="info-label">Stop Multiplier</span>
          <span class="info-val" style="color:${stopColor}">${stop_multiplier.toFixed(1)}×ATR
            <span style="color:#484f58;font-size:10px">/ ${default_stop_mult.toFixed(1)} default</span>
          </span>
        </div>
        <div class="info-row">
          <span class="info-label">Overall Win Rate</span>
          <span class="info-val" style="color:${wrColor}">${overall_win_rate !== null ? overall_win_rate + '%' : '—'}</span>
        </div>
        <div class="info-row">
          <span class="info-label">Closed Trades</span>
          <span class="info-val">${total_closed}</span>
        </div>
        <div style="font-size:11px;color:#484f58;margin-top:10px;line-height:1.6">
          Adapts every time a trade closes.<br>
          Needs ≥3 trades per factor before adjusting.<br>
          Threshold range: 6.5 – 9.0<br>
          Weight range: 30% – 150% of default
        </div>
      </div>
      <div class="col-xl-4 col-12">
        <div style="font-size:10px;color:var(--text-dim);text-transform:uppercase;letter-spacing:.06em;margin-bottom:8px">
          Recent Adaptation Log
        </div>
        <div style="max-height:220px;overflow-y:auto">
          ${logHtml}
        </div>
      </div>
    </div>`;
}

// ═══════════════════════════════════════════════════════
// AUTO REFRESH
// ═══════════════════════════════════════════════════════
function toggleAuto() {
  autoRefreshOn = !autoRefreshOn;
  const btn = document.getElementById('auto-btn');
  if (autoRefreshOn) {
    btn.textContent = 'Auto ▶ 5m';
    btn.style.color = '#3fb950';
    autoTimer = setInterval(() => forceRefresh(), 5 * 60 * 1000);
  } else {
    btn.textContent = 'Auto ⏸';
    btn.style.color = '';
    clearInterval(autoTimer);
  }
}

// ═══════════════════════════════════════════════════════
// HELPERS
// ═══════════════════════════════════════════════════════
function set(id, html, color) {
  const el = document.getElementById(id);
  if (!el) return;
  el.innerHTML = html;
  if (color) el.style.color = color;
}

function row(label, valueHtml) {
  return `<div class="info-row">
    <span class="info-label">${label}</span>
    <span class="info-val">${valueHtml}</span>
  </div>`;
}

function yn(v, trueLabel='Yes', falseLabel='No') {
  return v
    ? `<span class="text-g">${trueLabel}</span>`
    : `<span class="text-r">${falseLabel}</span>`;
}

function fmt(v) {
  if (v == null) return '—';
  const n = Number(v);
  if (n >= 10000) return n.toLocaleString('en-US', {minimumFractionDigits:0, maximumFractionDigits:0});
  if (n >= 1)     return n.toLocaleString('en-US', {minimumFractionDigits:2, maximumFractionDigits:4});
  return n.toLocaleString('en-US', {minimumFractionDigits:4, maximumFractionDigits:6});
}

function fmtDate(ts) {
  if (!ts) return '';
  const d = new Date(ts);
  return d.toLocaleDateString('en-US', {month:'short', day:'numeric', hour:'2-digit', minute:'2-digit'});
}

function regimeColor(regime) {
  if (!regime) return '#8b949e';
  if (regime.includes('Strong Up'))   return '#3fb950';
  if (regime.includes('Weak Up'))     return '#2ea043';
  if (regime.includes('Strong Down')) return '#f85149';
  if (regime.includes('Weak Down'))   return '#da3633';
  return '#d29922';
}

function setTimestamp(iso, age) {
  const d = new Date(iso);
  const ageStr = age < 60 ? 'just fetched' : `cached ${Math.floor(age/60)}m ago`;
  document.getElementById('timestamp').textContent =
    `Last: ${d.toLocaleTimeString()} UTC — ${ageStr}`;
}

function showLoading(msg) {
  const el = document.getElementById('loading-overlay');
  document.getElementById('loading-msg').textContent = msg || 'Loading...';
  el.style.display = 'flex';
}
function hideLoading() { document.getElementById('loading-overlay').style.display = 'none'; }
function showError(msg) {
  const el = document.getElementById('error-banner');
  el.textContent = '⚠ ' + msg;
  el.style.display = 'block';
}
function hideError() { document.getElementById('error-banner').style.display = 'none'; }
</script>
</body>
</html>
